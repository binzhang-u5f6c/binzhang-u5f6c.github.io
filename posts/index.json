[
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E5%B1%B1%E5%A4%A7%E9%A3%9F%E8%AE%B0/",
        "title": "山大食记",
        "section": "posts",
        "tags": ["多余的话"],
        "date" : "2021.10.15",
        "body": "一 第一次吃山大食堂是来上大学的第二天。\n一觉醒来已经有些晚了。 我记得那天天气很好，阳光明媚，在九月初秋晒得人很舒服，我和我的高中同学阿垚一起去吃早饭。 我们是从食堂的南门进入，食堂的人很多，每个窗口排了长长的队伍。 我们随便选了一个窗口，跟着前面人，购买了人生中第一张鸡蛋饼。 打饭阿姨的旁边摞了几摞鸡蛋饼，像宝塔一样。 我们也没想到我们吃的就是日后令无数山大毕业生想念的山大鸡蛋饼。 松软的饼身里混入了点点葱花，彰显葱省味道，饼身上的鸡蛋则带来紧实的口感，鸡蛋之上则是一层酥脆的表皮。 一口下去，层次分明。 从边缘开始吃，咬到中间则是一个完整的蛋黄，丰富的蛋白质和胆固醇带来最原始的满足。\n我本以为鸡蛋饼将会是我的每日早餐，但越来越晚起床时间则压缩了去食堂的时间，直至教学楼下的手抓饼替代了鸡蛋饼。\n二 如果说再给我一次机会，让我回学校食堂吃一次饭，我一定会选二楼的石锅拌饭。\n第一次尝试石锅拌饭还是在大一下学期。 那个学期课业繁重，必修课就有33学分，在加上一门选修课，课程表排得满满当当。 上午上完第四节课再磨蹭一下，食堂的大部分窗口都没什么菜了。 二楼的石锅窗口是为数不多的选择。 米饭之上整齐地码放着西葫、豆芽和鸡肉，其上再铺一层辣酱，最后盖一个煎蛋。 用食堂的不锈钢汤匙轻轻戳破煎蛋，将蔬菜、鸡肉、辣酱和米饭拌在一起， 辣酱触碰到高温的石锅，发出嗤嗤的声响，香气也随着冒起的白烟扑入口鼻，让人食指大动。 拌匀之后一勺入口，首先是米饭混杂着煎蛋，又滑又嫩， 接着辣酱的辣味携裹着米饭和鸡蛋的香气直冲鼻腔，让人欲罢不能。 嚼上几口，则能感受到豆芽和西葫的爽脆可口。 吃过一次之后，我就成了石锅窗口的忠实食客。 下课之后，来干一碗拌饭，吃完心满意足地聊会儿天，把石锅送回窗口， 就该背起书包，去洪家楼做物理实验了。 即使到了高年级，课业逐渐轻松，在吃的方面有了更多的选择，我还是常常来二楼大快朵颐。 石锅拌饭已经成为我的默认选项，在我不知道吃什么的时候，就去二楼吃石锅拌饭。\n三 大家都说三楼的水饺很好吃，但我对水饺并不感冒，所以很少去吃。 只有在过洋节的时候突发奇想，才会去吃一次， 再配上一些诸如“俺们北方人圣诞节当然是吃饺子啦”的文案发到朋友圈。 不过有一说一，三楼的番茄鸡蛋馅儿水饺虽然听上去像黑暗料理，但吃起来真的不错。 三楼的水饺窗口还有一个功能，那就是让学生自己包饺子下饺子吃。\n我们班的团建活动屈指可数，一起包饺子算一个。 在大一的冬至，我们班就组织了包饺子活动。 食堂提供和好的面、剁好的馅儿，我们只要包就好。 说起来令人尴尬，我们一个班只有一个人能够熟练地擀饺子皮， 但总不能让一个人擀啊，那没包完饺子大家都饿死了。 于是大家各显神通，擀出的饺子皮自然千形百状。 大家包饺子的手法也不尽相同，包出来的饺子有的像笼包，有的像锅贴，就是不像饺子。 最终，这一顿水饺令大家难忘， 只是不知给我下饺子的食堂阿姨对我们的“杰作”作何感想。\n四 如果说食堂是山大生活设施的皇冠，那么一多餐厅就是这皇冠上的明珠。 如果用一个词来形容一多餐厅的话，那就是精致。 牛排意面套餐，各种煲饭，各式甜品，以及琳琅满目的菜品，应有尽有，厨师还会推出一些网红菜品，譬如路飞的大骨肉棒。 对我来说最为惊喜的是，在春天这里居然能吃的到新鲜的香椿芽。\n我从小就喜欢吃香椿芽，无论是裹着面糊炸，还是炒鸡蛋，都很美味。 但香椿的时令性很强，很快芽叶就老了不好吃了。 因此食堂香椿芽供应很不稳定，即使是春天，也时有时无，能不能吃到看运气。 运气好碰上了来上一盘，香椿的独有香气混着鸡蛋香勾着人肚里的馋虫，每次都能一扫而光。 春日暖暖的太阳，吃上一盘香椿炒蛋，给人以新的一年新气象之感， 不由得发出诸如“新的一年我一定要好好学习”的flag。\n五 有的时候头天晚上熬夜，早上起得晚但又没到午饭时间，没关系，来地下一层来一碗热粥。 有的时候因为学习、开会错过了晚饭？没事，地下一层的灯光一直为你亮着。\n大四最后一个学期，黄大哥拉我一起早起练球。球技没什么长进，但保持了很长一段时间的规律作息。 为了能六点起床，我不能熬夜，十点半就得上床准备睡觉了。 刚开始的时候还是初春，天气很冷，天也短，还蒙蒙亮，诺大的篮球场只有我们两个人。 随着天气渐暖，白昼变长，篮球场也渐渐热闹起来，我这才发现原来学校里有这么多篮球爱好者早起练球。 练完休息一下后，快九点了，我俩就去地下一层吃早饭。 吃早饭前，我一般会去前台买一瓶冰脉动一饮而尽，消解运动后的疲惫。 运动之后我一般没什么食欲，喝一碗粥，吃一点水果，新的一天就开始了。 由春入夏，天气越来越暖和，球场的人也越来越多，场地也渐渐紧张起来，有时候我们会占不到场，只能去旁边排球场练一会儿运球。 占不到场地的情况发生得越来越频繁，我们俩也就慢慢不去练球了。当然，这都是后话了。\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/dynamic-programming/",
        "title": "Dynamic Programming",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.04.15",
        "body": "1. Rod cutting Three versions of rod cutting algorithms are implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int cut_rod(int *p, int n) { if (n == 0) return 0; int i, q = -0x7fffffff; for (i = 0; i \u0026lt; n; ++i) { int temp_q = p[i] + cut_rod(p, n-i-1); q = temp_q \u0026gt; q ? temp_q : q; } return q; } int memoized_cut_rod_aux(int *p, int n, int *r) { if (n == 0) return 0; if (r[n-1] \u0026gt;= 0) return r[n-1]; int i, q = -0x7fffffff; for (i = 0; i \u0026lt; n; ++i) { int temp_q = p[i] + memoized_cut_rod_aux(p, n-i-1, r); q = temp_q \u0026gt; q ? temp_q : q; } r[n-1] = q; return q; } int memoized_cut_rod(int *p, int n) { int i, *r = malloc(sizeof(int)*n); for (i = 0; i \u0026lt; n; ++i) r[i] = -0x7fffffff; int result = memoized_cut_rod_aux(p, n, r); free(r); return result; } int bottom_up_cut_rod(int *p, int n) { int i, j, *r = malloc(sizeof(int)*n); for (i = 0; i \u0026lt; n; ++i) { int q = -0x7fffffff; for (j = 0; j \u0026lt;= i; ++j) { int temp_q = j == i ? p[j] : p[j] + r[i-j-1]; q = temp_q \u0026gt; q ? temp_q : q; } r[i] = q; } int result = r[n-1]; free(r); return result; } 2. Matrix-chain multiplication Four steps to use dynamic programming:\n Characterize the structure of an optimal solution. Recursively define the value of an optimal solution. Compute the value of an optimal solution. Construct an optimal solution from computed information.  3. Elements of dynamic programming There are two key ingredients that an optimization problem must in order for dynamic programming to apply:\n Optimal substructure: an optimal solution contains within it optimal solution to subproblems. Overlapping subproblems: a recursive algorithm revisits the same subproblems repeatly.  4. Longest common subsequence A program to find the longest common subsequence of two strings is implemented below.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void lcs_length(char *x, int nx, char *y, int ny, int *c, int *aux_c) { int i, j; for (i = 0; i \u0026lt;= nx; ++i) c[i*(ny+1)] = 0; for (j = 0; j \u0026lt;= ny; ++j) c[j] = 0; for (i = 1; i \u0026lt;= nx; ++i) for (j = 1; j \u0026lt;= ny; ++j) if (x[i-1] == y[j-1]) { c[i*(ny+1)+j] = c[(i-1)*(ny+1)+(j-1)] + 1; aux_c[i*(ny+1)+j] = 0; } else if (c[i*(ny+1)+(j-1)] \u0026gt; c[(i-1)*(ny+1)+j]) { c[i*(ny+1)+j] = c[i*(ny+1)+(j-1)]; aux_c[i*(ny+1)+j] = -1; } else { c[i*(ny+1)+j] = c[(i-1)*(ny+1)+j]; aux_c[i*(ny+1)+j] = 1; } return; } void print_lcs_aux(char *y, int ny, int *aux_c, int i, int j) { if (i == 0 || j == 0) return; if (aux_c[i*(ny+1)+j] == 0) { print_lcs_aux(y, ny, aux_c, i-1, j-1); printf(\u0026#34;%c\u0026#34;, y[j-1]); } else if (aux_c[i*(ny+1)+j] == 1) print_lcs_aux(y, ny, aux_c, i-1, j); else print_lcs_aux(y, ny, aux_c, i, j-1); return; } void print_lcs(char *x, int nx, char *y, int ny) { int *c = malloc(sizeof(int)*(nx+1)*(ny+1)); int *aux_c = malloc(sizeof(int)*(nx+1)*(ny+1)); lcs_length(x, nx, y, ny, c, aux_c); print_lcs_aux(y, ny, aux_c, nx, ny); printf(\u0026#34;\\n\u0026#34;); free(c); free(aux_c); return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/augmenting-data-structures/",
        "title": "Augmenting Data Structures",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.04.08",
        "body": "1. Dynamic order statistics Via adding a new attribute size in a red-black tree, we can determine any order statistic in \\(O(n)\\) time. The size refer to the number of nodes of the subtree whose root is the node. It is called order-statistic tree.\n2. How to augment a data structure  Choose an underlying data structure. Determine additional information to maintain in the underlying data structure. Verify that we can maintain the additional information for the basic modifying operations on the underlying data structure. Develop new operations.  "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E5%BC%A0%E5%A4%A7%E8%B7%AF%E4%BC%A0%E5%A5%87/",
        "title": "张大路传奇",
        "section": "posts",
        "tags": ["多余的话"],
        "date" : "2021.04.05",
        "body": "张大路的名字叫张大路。 “大路”的意思就是很马虎，甚至有些糊涂，无论对什么事都不在乎。\n张大路喜欢网上冲浪。 他点开了第一篇帖子，叫做《 北京第一代“鸡娃”给大家讲讲内卷教育的切肤之痛 》， 讲的是一位北京女孩从小被妈妈”鸡“， 上辅导班，参加跨区招生考试， 高中的时候发表文章，去美国交换， 最终考上了北京电影学院导演系，当上编剧、作者的故事。 舞文弄墨，靠写一点东西来养活自己，是张大路从小的梦想。 要是在混一口饭之余，还能有钱买几本书读，那就更好了。 但是张大路并不擅长写作，他费劲脑汁蹦出的几个字并没有人愿意读， 扔到垃圾堆里也要被分类成有害垃圾。 张大路很羡慕能靠写作谋生的人。 人家是北儿京儿人儿，资源好，文字又很有灵性，高中就能发表文章， 自己怎么和人家比呢，张大路这样安慰自己。\n张大路点开了第二篇帖子，《 太苦了，听说这位自动化所的博士在工业界， 我一个男的看都想给他一个拥抱 》。 贴子是一位穷苦出身的男孩的博士论文致谢， 讲述了自己求学之路的经历。 帖子的主角跟随自动化所的一名九袋长老学习机器翻译， 并进入工业界继续在该领域发光发热。 这让张大路的内心十分羡慕。 张大路也梦想过研究机器翻译。 在发现自己的写作之路走不通后， 张大路觉得自己狗嘴吐不出象牙，那可不可以做翻译呢？ 把他国的象牙翻译成中国的象牙，也算是功德一件。 但张大路的外文也不好，他的全国大学生六级考试只有484分。 看上去张大路的翻译之路也要断绝了， 但是随着神经网络[1, 2]和attention机制[3]的发展， 机器翻译的质量发生了翻天覆地的飞跃。 去研究机器翻译似乎是一种曲线救国的路线呢，张大路这样想道。 目前国内机器翻译研究水平最高的就是该就职于自动化所的九袋长老。 张大路发现自己的一位亲戚居然也就职于自动化所， 就想托亲戚的关系套一下瓷。 就在这临门一脚的时刻，张大路自己却耸了，觉得自己配不上拜九袋长老为师。 后来又一次偶然的机会，张大路又去蹭了本校一位长老开设的高性能计算讲坛, 发现讲坛的内容对机器翻译所依赖的GPU计算的调优大有裨益， 研究一下高性能计算，可以说是曲线救国的曲线救国。 于是又想跟随该长老继续学习，却因编程经验不足而被拒绝。 当然，在仔细研究了神经机器翻译的原理后， 张大路觉得这种基于“编码-解码”的过程不能称之为翻译， 又不想做机器翻译了，这是后话了。\n张大路是学过数学分析的， 亲眼目睹两个人过上了自己的梦想（或者曾经的）人生， 一个家境优渥，一个出身困苦， 根据夹逼定理，自己也应该过着差不多的人生啊，为什么自己混成了现在这样子呢？\n张大路是学习金融数学的，曾经立志做一名quant在墙街呼风唤雨。 做quant编程是免不了的，张大路却在学习期间发现，编程真是太有趣了， 自己为什么不做一名coder呢？ 在大三的暑假，张大路郑重地决定，我要考计算机的研究生。 整个大三暑假，张大路都在阅读《算法导论》。 他看着红黑树左转又右转，插入又删除，把自己都看晕了。 张大路不禁问自己，自己这几斤几两真的能行吗？ 还好之前抱大腿，混了一个保研名额，要不先在本校读个研究生，再图后计。 于是张大路读了本校的研究生。 张大路继续磨练自己的编程手艺，以图他日投身coding事业。 就在张大路准备找实习的时候，一个出国读博的机会跳到了他的面前， 还是当前最火的机器学习方向。 送到嘴边的肥肉总不能不吃啊，张大路想道。 于是张大路去了国外读博。 回顾自己的前半生，张大路不禁感慨道，自己真是人如其名啊。 张大路的一生，是大路的一生。 从金融数学转专业计算机，放弃考研，出国读博， 每一步选择都太随意，被一时头脑发热所支配。 过于随意的选择，以及自身的懒惰，导致张大路的人生跳出了夹逼。\n张大路不是一个怨天尤人的人。 张大路拿起枕边的《欢乐英雄》，读起了郭大路的故事。 郭大路去做镖师，却把押运的银子分给了劫路的强盗。 郭大路去做厨子，把糖醋鱼摔到了客人的脸上。 郭大路去卖艺，却一套开山功，一招扫堂腿，把观众都吓跑了。 哈哈，真滑稽！张大路不禁笑了起来。 “他们懂得生命是可贵的，也懂得如何去享受生命。” 张大路一字一字地念着， “这一生中，他们做了许多出人意料、令人倒绝的事。 你也许会认为他们做的事很愚蠢，很可笑。 但你却不能不承认，他们做的事别人做不到。 你也做不到，所以你一定喜欢听他们的故事。”\n参考文献\n[1] Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014. Sequence to Sequence Learning with Neural Networks. In Proceedings of NIPS 2014.\n[2] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2015. Neural Machine Translation by Jointly Learning to Align and Translate. In Proceedings of ICLR 2015.\n[3] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is All You Need. In Proceedings of NIPS 2017.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/red-black-trees/",
        "title": "Red-Black Trees",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.04.01",
        "body": "1. Properties of red-black trees A red-black tree is a binary search tree with one extra attribute per node: its color, which can be either RED or BLACK.\nAs a matter of convenience, we introduce a single sentinel and all leaf nodes point to this sentinel. A red-black tree satisfies the following properties:\n Every node is either red or black. The root is black. The sentinel is black. If a node is red, then both its children are black. For each node, all simple paths from the node to the sentinel contain the same number of black nodes.  Thus red-black trees ensure that no such path is more than twice as long as any other, so that the tree is balanced. A red-black tree with \\(n\\) nodes has height at most \\(2\\log(n+1)\\).\n2. Rotation, insertion and deletion To keep the properties while insertion and deletion, new operation rotation is necessary.\nAn interger red-black tree is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; struct object { int key; char color; struct object *p, *left, *right; }; struct red_black_tree { struct object *root, *sentinel; }; /*********** * search * ***********/ struct object *rb_tree_search(struct object *x, int k) { if (x == NULL || k == x-\u0026gt;key) return x; if (k \u0026lt; x-\u0026gt;key) return rb_tree_search(x-\u0026gt;left, k); else return rb_tree_search(x-\u0026gt;right, k); } struct object *rb_tree_min(struct object *x) { while (x-\u0026gt;left != NULL) x = x-\u0026gt;left; return x; } struct object *rb_tree_max(struct object *x) { while (x-\u0026gt;right != NULL) x = x-\u0026gt;right; return x; } struct object *rb_tree_successor(struct object *x) { if (x-\u0026gt;right != NULL) return rb_tree_min(x-\u0026gt;right); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;right) {x = y; y = y-\u0026gt;p;} return y; } struct object *rb_tree_predecessor(struct object *x) { if (x-\u0026gt;left != NULL) return rb_tree_max(x-\u0026gt;left); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;left) {x = y; y = y-\u0026gt;p;} return y; } /************* * rotation * *************/ void left_rotate(struct red_black_tree *T, struct object *x) { struct object *y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; if (y-\u0026gt;left != T-\u0026gt;sentinel) y-\u0026gt;left-\u0026gt;p = x; y-\u0026gt;p = x-\u0026gt;p; if (x-\u0026gt;p == T-\u0026gt;root) T-\u0026gt;root = y; else if (x-\u0026gt;p-\u0026gt;left == x) x-\u0026gt;p-\u0026gt;left = y; else x-\u0026gt;p-\u0026gt;right = y; y-\u0026gt;left = x; x-\u0026gt;p = y; return; } void right_rotate(struct red_black_tree *T, struct object *x) { struct object *y = x-\u0026gt;left; x-\u0026gt;left = y-\u0026gt;right; if (y-\u0026gt;right != T-\u0026gt;sentinel) y-\u0026gt;right-\u0026gt;p = x; y-\u0026gt;p = x-\u0026gt;p; if (x-\u0026gt;p == T-\u0026gt;root) T-\u0026gt;root = y; else if (x-\u0026gt;p-\u0026gt;left == x) x-\u0026gt;p-\u0026gt;left = y; else x-\u0026gt;p-\u0026gt;right = y; y-\u0026gt;right = x; x-\u0026gt;p = y; return; } /************** * insertion * **************/ void rb_insert_fixup(struct red_black_tree *T, struct object *z) { while (z-\u0026gt;p-\u0026gt;color == \u0026#39;r\u0026#39;) { if (z-\u0026gt;p == z-\u0026gt;p-\u0026gt;p-\u0026gt;left) { struct object *y = z-\u0026gt;p-\u0026gt;p-\u0026gt;right; if (y-\u0026gt;color == \u0026#39;r\u0026#39;) { z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; y-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; z = z-\u0026gt;p-\u0026gt;p; } else { if (z == z-\u0026gt;p-\u0026gt;right) { z = z-\u0026gt;p; left_rotate(T, z); } z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; right_rotate(T, z-\u0026gt;p-\u0026gt;p); } } else { struct object *y = z-\u0026gt;p-\u0026gt;p-\u0026gt;left; if (y-\u0026gt;color == \u0026#39;r\u0026#39;) { z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; y-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; z = z-\u0026gt;p-\u0026gt;p; } else { if (z == z-\u0026gt;p-\u0026gt;left) { z = z-\u0026gt;p; right_rotate(T, z); } z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; left_rotate(T, z-\u0026gt;p-\u0026gt;p); } } } return; } void rb_insert(struct red_black_tree *T, struct object *z) { struct object *x = T-\u0026gt;root, *y = T-\u0026gt;sentinel; while (x != T-\u0026gt;sentinel) { y = x; if (z-\u0026gt;key \u0026lt; x-\u0026gt;key) x = x-\u0026gt;left; else x = x-\u0026gt;right; } z-\u0026gt;p = y; if (y == T-\u0026gt;sentinel) T-\u0026gt;root = z; else if (z-\u0026gt;key \u0026lt; y-\u0026gt;key) y-\u0026gt;left = z; else y-\u0026gt;right = z; z-\u0026gt;left = T-\u0026gt;sentinel; z-\u0026gt;right = T-\u0026gt;sentinel; z-\u0026gt;color = \u0026#39;r\u0026#39;; rb_insert_fixup(T, z); return; } /************* * deletion * *************/ void rb_transplant(struct red_black_tree *T, struct object *u, struct object *v) { if (u-\u0026gt;p == T-\u0026gt;sentinel) T-\u0026gt;root = v; else if (u == u-\u0026gt;p-\u0026gt;left) u-\u0026gt;p-\u0026gt;left = v; else u-\u0026gt;p-\u0026gt;right = v; v-\u0026gt;p = u-\u0026gt;p; return; } void rb_delete_fixup(struct red_black_tree *T, struct object *x) { struct object *w; while (x != T-\u0026gt;sentinel \u0026amp;\u0026amp; x-\u0026gt;color == \u0026#39;b\u0026#39;) { if (x == x-\u0026gt;p-\u0026gt;left) { w = x-\u0026gt;p-\u0026gt;right; if (w-\u0026gt;color == \u0026#39;r\u0026#39;) { w-\u0026gt;color = \u0026#39;b\u0026#39;; x-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; left_rotate(T, x-\u0026gt;p); w = x-\u0026gt;p-\u0026gt;right; } if (w-\u0026gt;left-\u0026gt;color == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;color = \u0026#39;r\u0026#39;; x = x-\u0026gt;p; } else { if (w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;left-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;color = \u0026#39;r\u0026#39;; right_rotate(T, w); x = x-\u0026gt;p-\u0026gt;right; } w-\u0026gt;color = x-\u0026gt;p-\u0026gt;color; x-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;right-\u0026gt;color = \u0026#39;b\u0026#39;; left_rotate(T, x-\u0026gt;p); x = T-\u0026gt;root; } } else { w = x-\u0026gt;p-\u0026gt;left; if (w-\u0026gt;color == \u0026#39;r\u0026#39;) { w-\u0026gt;color = \u0026#39;b\u0026#39;; x-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; right_rotate(T, x-\u0026gt;p); w = x-\u0026gt;p-\u0026gt;left; } if (w-\u0026gt;left-\u0026gt;color == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;color = \u0026#39;r\u0026#39;; x = x-\u0026gt;p; } else { if (w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;left-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;color = \u0026#39;r\u0026#39;; left_rotate(T, w); x = x-\u0026gt;p-\u0026gt;left; } w-\u0026gt;color = x-\u0026gt;p-\u0026gt;color; x-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;right-\u0026gt;color = \u0026#39;b\u0026#39;; right_rotate(T, x-\u0026gt;p); x = T-\u0026gt;root; } } } x-\u0026gt;color = \u0026#39;b\u0026#39;; return; } void rb_delete(struct red_black_tree *T, struct object *z) { struct object *x, *y; y = z; char y_original_color = y-\u0026gt;color; if (z-\u0026gt;left == T-\u0026gt;sentinel) { x = z-\u0026gt;right; rb_transplant(T, z, z-\u0026gt;right); } else if (z-\u0026gt;right == T-\u0026gt;sentinel) { x = z-\u0026gt;left; rb_transplant(T, z, z-\u0026gt;left); } else { y = rb_tree_min(z-\u0026gt;right); y_original_color = y-\u0026gt;color; x = y-\u0026gt;right; if (y-\u0026gt;p != z) { rb_transplant(T, y, y-\u0026gt;right); y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;p = y; } rb_transplant(T, z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;p = y; y-\u0026gt;color = z-\u0026gt;color; } if (y_original_color == \u0026#39;b\u0026#39;) rb_delete_fixup(T, x); return; } 3. Other balanced search trees The idea of balancing a search tree is due to AVL trees in 1962. Another class of search trees, called 2-3 trees was introduced in 1970. Skip lists provide an alternative to balanced search trees.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/binary-search-trees/",
        "title": "Binary Search Trees",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.30",
        "body": "What is a binary search tree? A binary search tree is organized in a binary tree. The tree is represented by a linked data structure in which each node is an object. In addition to a key and satellite data, each object contains 3 more attributes: left, right and parent\nThe keys in a binary search tree are always stored in such a way as to satify that for each node in a binary search tree, the key of any node in its left subtree is smaller than its own key, and the key of any node in its right subtree is larger than its own key,\nQuerying a binary search tree Besides the SEARCH operation, binary search trees support queries as MINIMUM, MAXIMUM, SUCCESSOR and PREDECESSOR.\nInsertion and deletion To insert a new element to a binary search tree is relatively straightforward, but handling deletion when the node has both two children is somewhat more intricate.\nAn interger binary search tree is implemented below.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; struct object { int key; struct object *p, *left, *right; }; struct binary_search_tree { struct object *root; }; void inorder_tree_walk(struct object *x) { if (x != NULL) { inorder_tree_walk(x-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, x-\u0026gt;key); inorder_tree_walk(x-\u0026gt;right); } printf(\u0026#34;\\n\u0026#34;); return; } /*********** * search * ***********/ struct object *tree_search(struct object *x, int k) { if (x == NULL || k == x-\u0026gt;key) return x; if (k \u0026lt; x-\u0026gt;key) return tree_search(x-\u0026gt;left, k); else return tree_search(x-\u0026gt;right, k); } struct object *tree_min(struct object *x) { while (x-\u0026gt;left != NULL) x = x-\u0026gt;left; return x; } struct object *tree_max(struct object *x) { while (x-\u0026gt;right != NULL) x = x-\u0026gt;right; return x; } struct object *tree_successor(struct object *x) { if (x-\u0026gt;right != NULL) return tree_min(x-\u0026gt;right); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;right) {x = y; y = y-\u0026gt;p;} return y; } struct object *tree_predecessor(struct object *x) { if (x-\u0026gt;left != NULL) return tree_max(x-\u0026gt;left); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;left) {x = y; y = y-\u0026gt;p;} return y; } /************** * insertion * **************/ void tree_insert(struct binary_search_tree *T, struct object *z) { struct object *x = T-\u0026gt;root, *y = NULL; while (x != NULL) { y = x; if (z-\u0026gt;key \u0026lt; x-\u0026gt;key) x = x-\u0026gt;left; else x = x-\u0026gt;right; } z-\u0026gt;p = y; if (y == NULL) T-\u0026gt;root = z; else if (z-\u0026gt;key \u0026lt; y-\u0026gt;key) y-\u0026gt;left = z; else y-\u0026gt;right = z; return; } /************* * deletion * *************/ void transplant(struct binary_search_tree *T, struct object *u, struct object *v) { if (u-\u0026gt;p == NULL) T-\u0026gt;root = v; else if (u == u-\u0026gt;p-\u0026gt;left) u-\u0026gt;p-\u0026gt;left = v; else u-\u0026gt;p-\u0026gt;right = v; if (v != NULL) v-\u0026gt;p = u-\u0026gt;p; return; } void tree_delete(struct binary_search_tree *T, struct object *z) { if (z-\u0026gt;left == NULL) transplant(T, z, z-\u0026gt;right); else if (z-\u0026gt;right == NULL) transplant(T, z, z-\u0026gt;left); else { struct object *y = tree_min(z-\u0026gt;right); if (y-\u0026gt;p != z) { transplant(T, y, y-\u0026gt;right); y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;p = y; } transplant(T, z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;p = y; } } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/hash-tables/",
        "title": "Hash Tables",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.28",
        "body": "1. Direct-address tables To represent a dynamic set in which the keys are drawn from a small universe, we use a direct-address table, in which each slot corresponds to a key in the universe.\n2. Hash tables Hash tables is similar to direct-address tables. With direct addressing, an element with key \\(k\\) is stored in slot \\(k\\). With hashing, an element with key \\(k\\) is stored in slot \\(h(k)\\), where \\(h\\) is a hash function.\nHowever, two keys may hash to the same slot. We call this situation a collision. The simplest collision resolution technique is chaining. We place all elements that hash to the same slot into a linked list. Given a hash table with \\(m\\) slots storing \\(n\\) elements, a search takes average-case time \\(\\Theta(1+n/m)\\).\n3. Hash functions To map a key \\(k\\) into one of \\(m\\) slots, the hash function of division method is\n[h(k) = k \\mod m,]\nand that of multiplication method is\n[h(k) = \\lfloor m(kA \\mod 1) \\rfloor,]\nwhere \\(0 \u0026lt; A \u0026lt; 1\\).\nUniversal hashing is to choose the hash function randomly in a way that is independent of the keys that are actually going to be stored.\nAn integer hash table with chaining and division hash function is implemented below.\n#include \u0026lt;stdlib.h\u0026gt;#define HASH_TABLE_SIZE 1024  struct object { int key; struct object *prev, *next; }; struct hash_table { struct object *T[HASH_TABLE_SIZE]; }; struct object *hash_search(struct hash_table *h, int k) { int index = k / HASH_TABLE_SIZE; struct object *re = h-\u0026gt;T[index]; while (re != NULL \u0026amp;\u0026amp; re-\u0026gt;key != k) re = re-\u0026gt;next; return re; } void hash_insert(struct hash_table *t, struct object *x) { int index = x-\u0026gt;key / HASH_TABLE_SIZE; x-\u0026gt;next = t-\u0026gt;T[index]; if (t-\u0026gt;T[index] != NULL) t-\u0026gt;T[index]-\u0026gt;prev = x; x-\u0026gt;prev = NULL; t-\u0026gt;T[index] = x; return; } void hash_delete(struct hash_table *h, struct object *x) { int index = x-\u0026gt;key / HASH_TABLE_SIZE; if (x-\u0026gt;prev != NULL) x-\u0026gt;prev-\u0026gt;next = x-\u0026gt;next; else h-\u0026gt;T[index] = x-\u0026gt;next; if (x-\u0026gt;next != NULL) x-\u0026gt;next-\u0026gt;prev = x-\u0026gt;prev; return; } 4. Open addressing Another collision resolution technique is open addressing. In open addressing, each table entry contains an element, NULL or DELETED. To insert an element, we probe the table until finding an empty slot. The probe sequence is generated by a hash function,\n[\\{h(k, 0), h(k, 1), \\dots, h(k, m-1)\\},]\nand is required to be a permutation. To search an element, we probe the table until finding the element or a NULL. To delete an element, we mark the corresponding slot with DELETED.\nThere are three commonly used techniques to compute the probe sequence.\n Linear probing: \\(h(k, i) = (h'(k) + i) \\mod m\\), Quadratic probing: \\(h(k, i) = (h'(k) + c_1i + c_2i^2) \\mod m\\), Double hashing: \\(h(k, i) = (h'(k) + h''(k)) \\mod m\\),  where \\(h'(k), h''(k)\\) are ordinary hash functions.\nLet \\(\\alpha = n/m\\), the expected number of probes in an unsuccessful search is \\(1/(1-\\alpha)\\), and that in a successful search is \\(\\frac{1}{\\alpha} \\ln \\frac{1}{1-\\alpha}\\).\n5. Perfect hashing If the set of keys is static, \\(O(1)\\) memory accesses can be satisfied with perfect hashing technique. The structure is similar to hash tables with chaining. Instead of making a linked list of the keys hashing to the same slot, we use a small secondary hash table. By choosing the hash function carefully, we can guarantee that there are no collisions.\nThe size of the secondary hash table is the square of the number of keys hashing to this slot. However the total size of hash table is \\(O(n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/elementary-data-structures/",
        "title": "Elementary Data Structures",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.17",
        "body": "1. Stacks and queues Stacks and queues are dynamic sets. The stack implements a last-in, first-out policy, while the queue implements a first-in, first-out policy.\nAn integer stack of size 1024 is implemented below.\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; struct stack { int a[1024]; int top; }; void push(struct stack *s, int x) { if (s-\u0026gt;top == 1023) { fprintf(stderr, \u0026#34;Overflow!\\n\u0026#34;); exit(1); } ++s-\u0026gt;top; s-\u0026gt;a[s-\u0026gt;top] = x; return; } int pop(struct stack *s) { if (s-\u0026gt;top == -1) { fprintf(stderr, \u0026#34;Underflow!\\n\u0026#34;); exit(1); } --s-\u0026gt;top; return s-\u0026gt;a[s-\u0026gt;top+1]; } An integer queue of size 1024 is implemented below.\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; struct queue { int a[1024]; int head, tail; }; void enqueue(struct queue *q, int x) { q-\u0026gt;a[q-\u0026gt;tail] = x; q-\u0026gt;tail = (q-\u0026gt;tail + 1) % 1024; if (q-\u0026gt;tail == q-\u0026gt;head) { fprintf(stderr, \u0026#34;Overflow!\\n\u0026#34;); exit(1); } return; } int dequeue(struct queue *q) { if (q-\u0026gt;head == q-\u0026gt;tail) { fprintf(stderr, \u0026#34;Underflow!\\n\u0026#34;); exit(1); } int x = q-\u0026gt;a[q-\u0026gt;head]; q-\u0026gt;head = (q-\u0026gt;head + 1) % 1024; return x; } 2. Linked lists A linked list is a linear-arranged data structure in which the order is determined by a pointer in each object.\nAn integer double linked list with a sentinel is implemented below.\nstruct object { int key; struct object *prev, *next; }; struct linked_list { struct object *sentinel; }; struct object* list_search(struct linked_list *L, int k) { struct object *re = L-\u0026gt;sentinel-\u0026gt;next; while (re != L-\u0026gt;sentinel \u0026amp;\u0026amp; re-\u0026gt;key != k) re = re-\u0026gt;next; return re; } void list_insert(struct linked_list *L, struct object *x) { x-\u0026gt;next = L-\u0026gt;sentinel-\u0026gt;next; L-\u0026gt;sentinel-\u0026gt;next-\u0026gt;prev = x; x-\u0026gt;prev = L-\u0026gt;sentinel; L-\u0026gt;sentinel-\u0026gt;next = x; return; } void list_delete(struct linked_list *L, struct object *x) { x-\u0026gt;prev-\u0026gt;next = x-\u0026gt;next; x-\u0026gt;next-\u0026gt;prev = x-\u0026gt;prev; return; } 3. Implementing pointers and objects We can use three arrays to implement a double linked list. For an index i, key[i], next[i] and prev[i] represent an object in the double linked list.\nA single array can also be used to implement a linked list just like how operating systems manage the computer memory. We can use a linked list with only next attribute to implement a stack, which we call the free list, to record which objects are free.\n4. Representing rooted trees The representation of a binary is just like that of a linked list. The difference is objects of trees have two childs.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/medians-and-order-statistics/",
        "title": "Medians and Order Statistics",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.01",
        "body": "The \\(i\\)th order statistic of a set of \\(n\\) elements is the \\(i\\)th smallest element.\nA selection problem is to select the \\(i\\)th order statistic from a set of \\(n\\) distinct numbers.\n1. Minimum and maximum Every element except the winner must lose once in a comparison. Hence \\(n-1\\) comparisions are necessary to determine the minimum. The algorithm is implemented below.\nint minimum(int *a, int n) { int i, min = a[0]; for (i = 1; i \u0026lt; n; ++i) if (min \u0026gt; a[i]) min = a[i]; return min; } If we want to find the minimum and maximum simultaneously, only \\(3\\lfloor n/2 \\rfloor\\) comparisions are necessary. The algorithm is implemented below.\nvoid min_and_max(int *a, int n, int *mm) { int i = (n % 2 == 1)?1:0; mm[0] = a[0]; mm[1] = a[0]; for (; i \u0026lt; n-1; i += 2) if (a[i] \u0026lt; a[i+1]) { if (a[i] \u0026lt; mm[0]) mm[0] = a[i]; if (a[i+1] \u0026gt; mm[1]) mm[1] = a[i+1]; } else { if (a[i+1] \u0026lt; mm[0]) mm[0] = a[i+1]; if (a[i] \u0026gt; mm[1]) mm[1] = a[i]; } return; } 2. Selection in expected linear time The randomized select algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int partition(int *a, int b, int e) { int ae = a[e]; int i = b - 1, j = b; for (; j \u0026lt; e; ++j) { if (a[j] \u0026lt;= ae) { ++i; int temp = a[i]; a[i] = a[j]; a[j] = temp; } } a[e] = a[i+1]; a[i+1] = ae; return i + 1; } int randomized_partition(int *a, int b, int e) { int i = rand() % (e - b + 1) + b; int temp = a[i]; a[i] = a[e]; a[e] = temp; return partition(a, b, e); } int randomized_select_r(int *a, int b, int e, int i) { if (b == e) return a[b]; int m = randomized_partition(a, b, e); if (i == m - b) return a[b]; else if (i \u0026lt; m - b) return randomized_select_r(a, b, m-1, i); else return randomized_select_r(a, m+1, e, i-(m-b)-1); } int randomized_select(int *a, int n, int i) { return randomized_select_r(a, 0, n-1, i); } The worst-case running time is \\(\\Theta(n^2)\\). If the elements are distinct, the expected running time is \\(O(n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/sorting-in-linear-time/",
        "title": "Sorting in Linear Time",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.26",
        "body": "1. Lower bounds for sorting Any comparision sort algorithm requires \\(\\Omega(n \\log n)\\) comparisions int the worst case.\n2. Counting sort The counting sort algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void counting_sort(int *a, int n, int k) { int *b = (int *) malloc(sizeof(int)*n); int *c = (int *) malloc(sizeof(int)*k); int i; for (i = 0; i \u0026lt; k; ++i) c[i] = 0; for (i = 0; i \u0026lt; n; ++i) ++c[a[i]]; for (i = 1; i \u0026lt; k; ++i) c[i] += c[i-1]; for (i = n-1; i \u0026gt;= 0; --i) { b[c[a[i]]-1] = a[i]; --c[a[i]]; } for (i = 0; i \u0026lt; n; ++i) a[i] = b[i]; free(b); free(c); return; } 3. Radix sort The radix sort algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void radix_sort(int *a, int n, int d) { int *b = (int *) malloc(sizeof(int)*n); int *c = (int *) malloc(sizeof(int)*10); int i, j, e = 1; for (i = 0; i \u0026lt; d; ++i) { for (j = 0; j \u0026lt; 10; ++j) c[j] = 0; for (j = 0; j \u0026lt; n; ++j) ++c[a[j]/e%10]; for (j = 1; j \u0026lt; 10; ++j) c[j] += c[j-1]; for (j = n-1; j \u0026gt;= 0; --j) { b[c[a[j]/e%10]-1] = a[j]; --c[a[j]/e%10]; } for (j = 0; j \u0026lt; n; ++j) a[j] = b[j]; e *= 10; } free(b); free(c); return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/quicksort/",
        "title": "Quicksort",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.26",
        "body": "1. Description of quicksort The quicksort algorithm is implemented below.\nint partition(int *a, int b, int e) { int ae = a[e]; int i = b - 1, j = b; for (; j \u0026lt; e; ++j) { if (a[j] \u0026lt;= ae) { ++i; int temp = a[i]; a[i] = a[j]; a[j] = temp; } } a[e] = a[i+1]; a[i+1] = ae; return i + 1; } void quicksort_r(int *a, int b, int e) { if (b \u0026lt; e) { int m = partition(a, b, e); quicksort_r(a, b, m-1); quicksort_r(a, m+1, e); } return; } void quicksort(int *a, int n) { quicksort_r(a, 0, n-1); return; } 2. Performance of quicksort The worst-case behavior occurs when the partitioning routine produces one subproblem with \\(n-1\\) elements and one with 0 elements. And the running time is \\(\\Theta(n^2)\\).\nThe expected running time is \\(\\Theta(n\\log n)\\).\n3. A randomized version of quicksort The randomized_quicksort algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int randomized_partition(int *a, int b, int e) { int i = rand() % (e - b + 1) + b; int temp = a[i]; a[i] = a[e]; a[e] = temp; return partition(a, b, e); } void randomized_quicksort_r(int *a, int b, int e) { if (b \u0026lt; e) { int m = partition(a, b, e); randomized_quicksort_r(a, b, m-1); randomized_quicksort_r(a, m+1, e); } return; } void randomized_quicksort(int *a, int n) { randomized_quicksort_r(a, 0, n-1); return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/heapsort/",
        "title": "Heapsort",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.24",
        "body": "1. Heaps The heap data structure is an array that can be viewed as nearly complete binary tree. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point. The parent index of the \\(i\\)th element is \\(\\lceil i/2 \\rceil -1\\), the left child index is \\(2i+1\\), and the right child index is \\(2i+2\\).\nThere are two kinds of heaps, max-heap and min-heap. In a max-heap, for every node other than the root, the value is not larger than that of its parent. In a min-heap, for every node other than the root, the value is not smaller than that of its parent.\n2. Maintaining the heap property The algorithm is implemented below.\nvoid max_heapify(int *a, int n, int i) { int l = 2 * i + 1, r = 2 * i + 2; int temp, temp_i = i; if (l \u0026lt; n \u0026amp;\u0026amp; a[l] \u0026gt; a[i]) temp_i = l; if (r \u0026lt; n \u0026amp;\u0026amp; a[r] \u0026gt; a[temp_i]) temp_i = r; if (temp_i != i) { temp = a[i]; a[i] = a[temp_i]; a[temp_i] = temp; max_heapify(a, n, temp_i); } return; } 3. Building a heap The algorithm is implemented below.\nvoid build_max_heap(int *a, int n) { int i = n / 2 - 1; for (; i \u0026gt;= 0; --i) max_heapify(a, n, i); return; } 4. The heapsort algorithm The algorithm is implemented below.\nvoid heap_sort(int *a, int n) { int i, temp; build_max_heap(a, n); for (i = n - 1; i \u0026gt; 0; --i) { temp = a[0]; a[0] = a[i]; a[i] = temp; max_heapify(a, i, 0); } return; } The running time of heapsort is \\(O(n\\log n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/probabilistic-analysis-and-randomized-algorithms/",
        "title": "Probabilistic Analysis and Randomized Algorithms",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.22",
        "body": "1. The hiring problem We have used worst-case analysis in the previous analysis of problems. Another approach is probabilistic analysis, in which we analyze algorithms via average-case running time.\n2. Indicator random variables The indicator random variable associated with event \\(A\\) is defined as [I(A) = \\begin{cases} 1 \u0026amp; \\text{if \\(A\\) occurs,} \\\\ 0 \u0026amp; \\text{if \\(A\\) does not occur.} \\end{cases}]\nUsing indicator random variables, we obtain the average-case hiring cost of the hiring problem is \\(O(c \\log n)\\).\n3. Randomized algorithms In order to use probabilistic analysis, we need to know the distribution of the inputs. In many cases, we know very little about it. Yet we often use probability and randomness as a tool for algorithm design and analysis. An algorithm is randomized if its behavior is determined not only by its input but also by values produced by a random-number generator.\nThe permuting arrays algorithms are implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void permute_by_sorting(int *a, int n) { int *p = malloc(sizeof(int)*n); int i, j, temp_p, temp_a; for (i = 0; i \u0026lt; n; ++i) p[i] = rand(); for (i = 1; i \u0026lt; n; ++i) { temp_p = p[i]; temp_a = a[i]; j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; p[j] \u0026gt; temp_p) { p[j+1] = p[j]; a[j+1] = a[j]; j -= 1; } p[j+1] = temp_p; a[j+1] = temp_a; } free(p); return; } void randomize_in_place(int *a, int n) { int i, j, temp; for (i = 0; i \u0026lt; n; ++i) { j = rand() % n; temp = a[i]; a[i] = a[j]; a[j] = temp; } return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E6%B3%A5%E6%B3%9E/",
        "title": "泥泞",
        "section": "posts",
        "tags": ["多余的话"],
        "date" : "2021.01.01",
        "body": "一场大雪给2020年画上了终止符。大清早起来，窗外的世界已是银装素裹。雪一直都是人们赞美的对象，它洁白无暇，冰清玉洁，往往是高洁的象征。但是当白雪融化，美好的一切却又变了样。\n每当这个时候，我总会想起高中做的一篇现代文阅读，迟子建的《泥泞》。我也记不清整个高中总共做过多少篇现代文阅读，甚至记不清高考的现代文阅读是哪篇，但这篇却总在我的记忆里不曾被忘记。 迟子建说，北方的初春是肮脏的，这肮脏当然源自于我们曾经热烈赞美过的纯洁无瑕的雪。 在不那么靠北的地方，不需要等到初春，太阳出来不久，雪就已经开始融化。早起的做题家和打工人匆匆走过，雪地上的脚印一层叠着一层，洁白的雪也从白色变成灰色，又变成黑色。太阳渐渐升高，雪渐渐融化，雪水将灰尘和剩下的还未融化的雪混合在一起，变成了可乐味的碎碎冰。\n迟子建说她“热爱这种浑然天成的泥泞”，我可一点都不喜欢。我小心翼翼地走在碎碎冰里，混合着泥污的雪吸附在我的鞋边，就像在我的鞋上围了一层抹布。脚步要是稍微重一点的话，泥水便会溅到裤子上。可总不能因为怕脏，就不往前走了。要是走雪路，就放开了在雪地撒欢；要是走泥路，就慢慢地轻轻地走；要是泥水结了冰，就小步小步地往前挪。不一样地路有不一样地走法，或快或慢，有潇洒也有狼狈，总不能因为不愿弄脏裤子就停步不前，更不能因为前路结冰就被吓得尿裤子。\n前路未卜，但行无妨。走一个虎虎生风，走一个一日千里，走一个恍如隔世。\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/sed-and-awk/",
        "title": "Sed and Awk",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.09.30",
        "body": "1. Sed # read from stdin and execute command sed \u0026#39;command\u0026#39; # read from a file and execute command sed \u0026#39;command\u0026#39; filename # read from a file and execute multiple commands sed \u0026#39;command1; command2\u0026#39; filename sed \u0026#39; command1 command2\u0026#39; filename 1.1 Address and pattern You can specify lines to which the command is applied using address. The address can be a line number 2, or a range of lines 2,3.\nsed \u0026#39;2,3command\u0026#39; # OR sed -e \u0026#39;2 { commands }\u0026#39; You can also filter lines using text pattern.\nsed \u0026#39;/pattern/command\u0026#39; 1.2 Basic edition Substituting command.\nsed \u0026#39;s/string1/string2/[flag]\u0026#39; file The command only replace the first occurrence in each line. Using flag g to replace all occurrences.\nDeleting command is usually in conjunction with address or text pattern.\nsed \u0026#39;2d\u0026#39; filename sed \u0026#39;3,$d\u0026#39; filename sed \u0026#39;/number 1/d\u0026#39; filename Inserting and appending commands.\n# insert before line sed \u0026#39;[address]i\\newline\u0026#39; filename # append after line sed \u0026#39;[address]a\\newline\u0026#39; filename Changing command.\nsed \u0026#39;[address]c\\newline\u0026#39; filename Transforming command.\nsed \u0026#39;[address]y/inchars/outchars/\u0026#39; filename Printing command. Use option -n to ignore all output except printing command.\n# print the line sed -n \u0026#39;[address]p\u0026#39; filename # print the line number sed -n \u0026#39;[address]=\u0026#39; filename # print the line with nonprintable characters sed -n \u0026#39;[address]l\u0026#39; filename Writing command. Note that the sed do not change the content in files.\nsed \u0026#39;[address]w filename2\u0026#39; filename1 Read and append the content from a file.\nsed \u0026#39;[address]r filename2\u0026#39; filename1 1.3 Yank and paste The buffer area that holds the text to be processed is called pattern space. Sed utilizes another buffer area called holding space for yanking and pasting.\nCopy command.\nsed \u0026#39;[address]h\u0026#39; # append the content to holding space sed \u0026#39;[address]H\u0026#39; Paste command.\nsed \u0026#39;[address]g\u0026#39; # append the content to pattern space sed \u0026#39;[address]G\u0026#39; Exchange command.\n# exchange the content sed \u0026#39;[address]x\u0026#39; 1.4 Negating commands # not paste sed -n \u0026#39;[address]!p\u0026#39; 1.5 Multiline commands Navigate the next line.\nsed -n \u0026#39;[address]{n;p}\u0026#39; Combine the next line.\nsed -n \u0026#39;[address]{N;p}\u0026#39; Only delete/print the first line.\nsed \u0026#39;[address]{N;D}\u0026#39; sed -n \u0026#39;[address]{N;P}\u0026#39; 2. Basic awk The awk program is similar to sed, but more powerful. It reads the contents line by line and executes script.\n# read from stdin and execute command awk \u0026#39;{script}\u0026#39; # read from a file and execute {script} awk \u0026#39;{script}\u0026#39; filename # read from a file and execute multiple commands awk \u0026#39;{script1; script2}\u0026#39; filename awk \u0026#39;{ script1 script2}\u0026#39; filename Some scripts can be run before or after processing data.\nawk \u0026#39;BEGIN {script1} {script2} END {script3}\u0026#39; 2.1 Use variables One of the primary features of awk is to manipulate data in the text file. Awk assigns $0 to represent the entire line, and $n to represent the nth data field. The data field is the contents separated by a field separation character. The default field separation character is any whitespace character, such as tab or space characters.\n# print the first data field of each line awk \u0026#39;{print $1}\u0026#39; You can use a different field separation character by changing the built-in variable FS.\n# print the first data field separated by \u0026#34;,\u0026#34; of each line awk \u0026#39;BEGIN {FS=\u0026#34;,\u0026#34;} {print $1}\u0026#39;    variable description     FS input field separation character   RS input record separation character   OFS output field separation character   ORS output record separation character    2.2 Use patterns Similar to sed, you can filter lines using text pattern. But awk provides more features.\nawk \u0026#39;/pattern/{script}\u0026#39; Filter in a specific data field.\n# only filter the text pattern in the data field 1 awk \u0026#39;$1 ~ /pattern/{script}\u0026#39; 2.3 Conditional expressions Operations include ==, \u0026lt;=, \u0026lt;, \u0026gt;= and \u0026gt;.\nawk \u0026#39;$1 == \u0026#34;data\u0026#34;{script}\u0026#39; 2.4 Formatted printing Awk provides a formatted printing command printf. It performs the same way with printf in C programming.\nawk \u0026#39;{printf \u0026#34;%d \u0026#34; $1}\u0026#39; awk \u0026#39;{printf \u0026#34;%.2f \u0026#34; $2}\u0026#39; awk \u0026#39;{printf \u0026#34;%12s\u0026#34; $3}\u0026#39; 2.5 Discussion Rather than just editor commands, awk is a programming language. As far as I\u0026rsquo;m concerned, features like structured statements, functions are not necessary. If the task is so complicated that loops or functions are needed, it would better to use other general-purpose languages, such as Perl/Ruby/Python. Thus the section about awk stops here.\n3. Regular expressions Regular expressions are keys to sed and awk. A regular expression is a pattern template you define to filter text.\n3.1 Basic regular expressions The simplest regular expression is plain text. Remember that regular expression patterns are case sensitive.\n# filter lines with word \u0026#39;hello\u0026#39; sed -n \u0026#39;/hello/p\u0026#39; awk \u0026#39;/hello/{print $0}\u0026#39; These special characters are recognized by regular expressions:\n.*[]^${}\\+?|() The backslash(\\) is used to escape special characters.\nsed -n \u0026#39;/\\$/p\u0026#39; Although forwardslash is not a special character, it is used to separate the pattern and command/script in sed/awk. Thus you need to escape it before use it\nsed -n \u0026#39;/\\//p\u0026#39; Anchor characters include the caret (^) and the dollar sign ($).\n# filter lines begin with the word \u0026#39;hello\u0026#39; sed -n \u0026#39;/^hello/p\u0026#39; # filter lines end with the word \u0026#39;world\u0026#39; sed -n \u0026#39;/world$/p\u0026#39; Note: if the caret is not at the beginning, or the dollar sign is not at the end, they do not act as special characters. which means you do not need to escape them.\nThe dot (.) is used to match any single character except a newline character.\n# filter lines with \u0026#39;.at\u0026#39;, such as \u0026#39;cat\u0026#39;, \u0026#39;hat\u0026#39;, and even \u0026#39; at\u0026#39; sed -n \u0026#39;/.at/p\u0026#39; Square brackets are used to define a class of characters.\n# filter lines with only \u0026#39;cat\u0026#39; or \u0026#39;hat\u0026#39; sed -n \u0026#39;/[ch]at/p\u0026#39; # filter lines with \u0026#39;.at\u0026#39; but except \u0026#39;cat\u0026#39; nor \u0026#39;hat\u0026#39; sed -n \u0026#39;/[^ch]at/p\u0026#39; # filter lines with \u0026#39;hello\u0026#39; non-case-sensitively sed -n \u0026#39;/[Hh][Ee][Ll][Ll][Oo]/p\u0026#39; Use ranges to simplify the character class.\n# filter lines with any digit sed -n \u0026#39;/[0-9]/p\u0026#39; # filter lines with any \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39; or \u0026#39;z\u0026#39; sed -n \u0026#39;/[a-cx-z]/p\u0026#39; There are also some special character classes:\n [[:alpha:]] means [a-zA-Z] [[:alnum:]] means [a-zA-Z0-9] [[:blank:]] means [ \\t] [[:digit:]] means [0-9] [[:lower:]] means [a-z] [[:upper:]] means [A-Z] [[:print:]] means any printable character [[:punct:]] means any punctuation character [[:space:]] means any whitespace character: Space, Tab, NL, FF, VT, CR  Placing an asterisk after a character signifies that the character must appear zero or more times.\n# filter lines with \u0026#39;scho*l\u0026#39;, such as \u0026#39;schl\u0026#39;, \u0026#39;schol\u0026#39; and \u0026#39;school\u0026#39;. sed -n \u0026#39;/scho*l/p\u0026#39; # combined with dot sed -n \u0026#39;/sch.*l/p\u0026#39; # combined with character class sed -n \u0026#39;/sch[oO]*l/p\u0026#39; 3.2 Extended regular expressions Extended regular expressions provide more features. But they are not supported by sed.\nThe question mark is used after a character to signify that the character must appear zero or one time.\n# filter lines with \u0026#39;bt\u0026#39; or \u0026#39;bet\u0026#39; sed -n \u0026#39;/be?t/p\u0026#39; The plus sign is used after a character to signify that the character must appear one or more times.\n# filter lines with \u0026#39;bet\u0026#39;, \u0026#39;beet\u0026#39; or \u0026#39;beeeeet\u0026#39; sed -n \u0026#39;/be+t/p\u0026#39; Curly braces are used to specify a limit on a repeatable pattern.\n# filter lines with \u0026#39;beet\u0026#39; sed -n \u0026#39;/be{2}t/p\u0026#39; # filter lines with \u0026#39;beet\u0026#39; or \u0026#39;beeet\u0026#39; sed -n \u0026#39;/be{2,3}t/p\u0026#39; The pipe symbol (|) is used to combine two or more patterns via logical OR.\n# filter lines with \u0026#39;cat\u0026#39; or \u0026#39;dog\u0026#39; sed -n \u0026#39;/cat|dog/p\u0026#39; Parentheses are used to group a pattern in another pattern.\n# here the pattern \u0026#39;urday\u0026#39; acts as a character sed -n \u0026#39;/Sat(urday)?/p\u0026#39; "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/divide-and-conquer/",
        "title": "Divide-and-Conquer",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.08.17",
        "body": "1. The maximum-subarray problem The algorithm is implemented below.\nvoid find_maximum_subarray(int *a, int *low, int *high) { if (*low == *high) return; int mid = (*low + *high) / 2, i; // left recursion  int low1 = *low, high1 = mid; find_maximum_subarray(a, \u0026amp;low1, \u0026amp;high1); int max1 = 0; for (i = low1; i \u0026lt;= high1; ++i) max1 += a[i]; // right recursion  int low2 = mid+1, high2 = *high; find_maximum_subarray(a, \u0026amp;low2, \u0026amp;high2); int max2 = 0; for (i = low2; i \u0026lt;= high2; ++i) max2 += a[i]; // subarray across mid point  // left part  int low3, sum_left = 0, max3_left = a[mid]; for (i = mid; i \u0026gt;= *low; --i) { sum_left += a[i]; if (sum_left \u0026gt;= max3_left) {low3 = i; max3_left = sum_left;} } // right part  int high3, sum_right = 0, max3_right = a[mid+1]; for (i = mid+1; i \u0026lt;= *high; ++i) { sum_right += a[i]; if (sum_right \u0026gt;= max3_right) {high3 = i; max3_right = sum_right;} } // merge  int max3 = max3_left + max3_right; // return  if (max1 \u0026gt;= max2 \u0026amp;\u0026amp; max1 \u0026gt;= max3) {*low = low1; *high = high1;} else if (max2 \u0026gt;= max3) {*low = low2; *high = high2;} else {*low = low3; *high = high3;} return; } 2. Strassen\u0026rsquo;s algorithm for matrix multiplication The square matrix multiply algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int* square_matrix_multiply(int *a, int *b, int d) { int i, j, k; int *c = malloc(sizeof(int)*d*d); for (i = 0; i \u0026lt; d; ++i) for (j = 0; j \u0026lt; d; ++j) { int index_c = d * i + j; *(c+ index_c) = 0; for (k = 0; k \u0026lt; d; ++k) { int index_a = d * i + k, index_b = d * k + j; *(c + index_c) += *(a + index_a) * *(b + index_b); } } return c; } The simple divide-and-conquer version is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int* square_matrix_multiply_recursive( int *a, int ax1, int ay1, int ax2, int ay2, int *b, int bx1, int by1, int bx2, int by2, int d) { int n = ax2 - ax1 + 1; int *c = malloc(sizeof(int)*n*n); if (n == 1) { *c = *(a + (ax1 * d + ay1)) * *(b + (bx1 *d + by1)); } else { int m = n / 2; int a11x1 = ax1, a11y1 = ay1, a11x2 = ax1+m-1, a11y2 = ay1+m-1; int a12x1 = ax1, a12y1 = ay1+m, a12x2 = ax1+m-1, a12y2 = ay2; int a21x1 = ax1+m, a21y1 = ay1, a21x2 = ax2, a21y2 = ay1+m-1; int a22x1 = ax1+m, a22y1 = ay1+m, a22x2 = ax2, a22y2 = ay2; int b11x1 = bx1, b11y1 = by1, b11x2 = bx1+m-1, b11y2 = by1+m-1; int b12x1 = bx1, b12y1 = by1+m, b12x2 = bx1+m-1, b12y2 = by2; int b21x1 = bx1+m, b21y1 = by1, b21x2 = bx2, b21y2 = by1+m-1; int b22x1 = bx1+m, b22y1 = by1+m, b22x2 = bx2, b22y2 = by2; int *c111 = square_matrix_multiply_recursive( a, a11x1, a11y1, a11x2, a11y2, b, b11x1, b11y1, b11x2, b11y2, d); int *c112 = square_matrix_multiply_recursive( a, a12x1, a12y1, a12x2, a12y2, b, b21x1, b21y1, b21x2, b21y2, d); int *c121 = square_matrix_multiply_recursive( a, a11x1, a11y1, a11x2, a11y2, b, b12x1, b12y1, b12x2, b12y2, d); int *c122 = square_matrix_multiply_recursive( a, a12x1, a12y1, a12x2, a12y2, b, b22x1, b22y1, b22x2, b22y2, d); int *c211 = square_matrix_multiply_recursive( a, a21x1, a21y1, a21x2, a21y2, b, b11x1, b11y1, b11x2, b11y2, d); int *c212 = square_matrix_multiply_recursive( a, a22x1, a22y1, a22x2, a22y2, b, b21x1, b21y1, b21x2, b21y2, d); int *c221 = square_matrix_multiply_recursive( a, a21x1, a21y1, a21x2, a21y2, b, b12x1, b12y1, b12x2, b12y2, d); int *c222 = square_matrix_multiply_recursive( a, a22x1, a22y1, a22x2, a22y2, b, b22x1, b22y1, b22x2, b22y2, d); int i, j; for (i = 0; i \u0026lt; m; ++i) for (j = 0; j \u0026lt; m; ++j) { *(c+(i*n+j)) = *(c111+(i*m+j)) + *(c112+(i*m+j)); *(c+(i*n+j+m)) = *(c121+(i*m+j)) + *(c122+(i*m+j)); *(c+((i+m)*n+j)) = *(c211+(i*m+j)) + *(c212+(i*m+j)); *(c+((i+m)*n+j+m)) = *(c221+(i*m+j)) + *(c222+(i*m+j)); } } return c; } The Strassen\u0026rsquo;s method is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int* square_matrix_multiply_strassens_method( int *a, int ax1, int ay1, int ax2, int ay2, int d1, int *b, int bx1, int by1, int bx2, int by2, int d2) { int n = ax2 - ax1 + 1; int *c = malloc(sizeof(int)*n*n); if (n == 1) { *c = *(a + (ax1 * d1 + ay1)) * *(b + (bx1 *d2 + by1)); } else { int m = n / 2; int a11x1 = ax1, a11y1 = ay1, a11x2 = ax1+m-1, a11y2 = ay1+m-1; int a12x1 = ax1, a12y1 = ay1+m, a12x2 = ax1+m-1, a12y2 = ay2; int a21x1 = ax1+m, a21y1 = ay1, a21x2 = ax2, a21y2 = ay1+m-1; int a22x1 = ax1+m, a22y1 = ay1+m, a22x2 = ax2, a22y2 = ay2; int b11x1 = bx1, b11y1 = by1, b11x2 = bx1+m-1, b11y2 = by1+m-1; int b12x1 = bx1, b12y1 = by1+m, b12x2 = bx1+m-1, b12y2 = by2; int b21x1 = bx1+m, b21y1 = by1, b21x2 = bx2, b21y2 = by1+m-1; int b22x1 = bx1+m, b22y1 = by1+m, b22x2 = bx2, b22y2 = by2; int *s1 = malloc(sizeof(int)*m*m); int *s2 = malloc(sizeof(int)*m*m); int *s3 = malloc(sizeof(int)*m*m); int *s4 = malloc(sizeof(int)*m*m); int *s5 = malloc(sizeof(int)*m*m); int *s6 = malloc(sizeof(int)*m*m); int *s7 = malloc(sizeof(int)*m*m); int *s8 = malloc(sizeof(int)*m*m); int *s9 = malloc(sizeof(int)*m*m); int *s10 = malloc(sizeof(int)*m*m); int i, j; for (i = 0; i \u0026lt; m; ++i) for (j = 0; j \u0026lt; m; ++j) { *(s1+(i*m+j)) = *(b+(b12x1+i)*d2+b12y1+j) - *(b+(b22x1+i)*d2+b22y1+j); *(s2+(i*m+j)) = *(a+(a11x1+i)*d1+a11y1+j) + *(a+(a12x1+i)*d1+a12y1+j); *(s3+(i*m+j)) = *(a+(a21x1+i)*d1+a21y1+j) + *(a+(a22x1+i)*d1+a22y1+j); *(s4+(i*m+j)) = *(b+(b21x1+i)*d2+b21y1+j) - *(b+(b11x1+i)*d2+b11y1+j); *(s5+(i*m+j)) = *(a+(a11x1+i)*d1+a11y1+j) + *(a+(a22x1+i)*d1+a22y1+j); *(s6+(i*m+j)) = *(b+(b11x1+i)*d2+b11y1+j) + *(b+(b22x1+i)*d2+b22y1+j); *(s7+(i*m+j)) = *(a+(a12x1+i)*d1+a12y1+j) - *(a+(a22x1+i)*d1+a22y1+j); *(s8+(i*m+j)) = *(b+(b21x1+i)*d2+b21y1+j) + *(b+(b22x1+i)*d2+b22y1+j); *(s9+(i*m+j)) = *(a+(a11x1+i)*d1+a11y1+j) - *(a+(a21x1+i)*d1+a21y1+j); *(s10+(i*m+j)) = *(b+(b11x1+i)*d2+b11y1+j) + *(b+(b12x1+i)*d2+b12y1+j); } int *p1 = square_matrix_multiply_strassens_method( a, a11x1, a11y1, a11x2, a11y2, d1, s1, 0, 0, m-1, m-1, m); int *p2 = square_matrix_multiply_strassens_method( s2, 0, 0, m-1, m-1, m, b, b22x1, b22y1, b22x2, b22y2, d2); int *p3 = square_matrix_multiply_strassens_method( s3, 0, 0, m-1, m-1, m, b, b11x1, b11y1, b11x2, b11y2, d2); int *p4 = square_matrix_multiply_strassens_method( a, a22x1, a22y1, a22x2, a22y2, d1, s4, 0, 0, m-1, m-1, m); int *p5 = square_matrix_multiply_strassens_method( s5, 0, 0, m-1, m-1, m, s6, 0, 0, m-1, m-1, m); int *p6 = square_matrix_multiply_strassens_method( s7, 0, 0, m-1, m-1, m, s8, 0, 0, m-1, m-1, m); int *p7 = square_matrix_multiply_strassens_method( s9, 0, 0, m-1, m-1, m, s10, 0, 0, m-1, m-1, m); for (i = 0; i \u0026lt; m; ++i) for (j = 0; j \u0026lt; m; ++j) { *(c+(i*n+j)) = *(p5+(i*m+j)) + *(p4+(i*m+j)) - *(p2+(i*m+j)) + *(p6+(i*m+j)); *(c+(i*n+j+m)) = *(p1+(i*m+j)) + *(p2+(i*m+j)); *(c+((i+m)*n+j)) = *(p3+(i*m+j)) + *(p4+(i*m+j)); *(c+((i+m)*n+j+m)) = *(p5+(i*m+j)) + *(p1+(i*m+j)) - *(p3+(i*m+j)) - *(p7+(i*m+j)); } } return c; } 3. The substitution method for solving recurrences The substitution method comprises two steps:\n Guess the form of the solution. Use mathematical induction to find the constants and show that the solution works.  Subtle skill: Sometimes you might correctly guess the solution of a recurrence, but some how the math fails to work out. For example, consider the recurrence,\n[T(n) = T(\\lfloor n/2 \\rfloor) + T(\\lceil n/2 \\rceil) + 1. ]\nWe guess the solution is \\(T(n) = O(n)\\). We obtain,\n[T(n) \\leq c\\lfloor n/2 \\rfloor + c\\lceil n/2 \\rfloor + 1 = cn + 1,]\nwhich does not implies \\(T(n) \\leq cn\\). If our guess is \\(T(n) \\leq cn - d\\), we have\n[T(n) \\leq cn -2d + 1.]\nwhich implies that \\(T(n) \\leq cn -d\\) as long as \\(d \\geq 1\\).\n4. The recursion-tree method for solving recurrences A recursion tree is usually used to generate a good guess. You can then verify by the substitution method. When using a recursion tree to generate a good guess, you can often tolerate a small amount of \u0026ldquo;sloppiness\u0026rdquo;.\n5. The master method for solving recurrences Let \\(a \\geq 1\\) and \\(b \u0026gt; 1\\) be constants, let \\(f(n)\\) be a function, and let \\(T(n)\\) be defined on the nonnegative integers by the recurrence [T(n) = aT(n/b) + f(n),] where we interpret \\(n/b\\) to mean either \\(\\lfloor n/b \\rfloor\\) or \\(\\lceil n/b \\rceil\\). Then \\(T(n)\\) has the following asymptotic bounds:\n If \\(f(n) = O(n^{\\log_b a - \\epsilon})\\) for some constant \\(\\epsilon \u0026gt; 0\\), then \\(T(n) = \\Theta(n^{\\log_b a})\\). If \\(f(n) = \\Theta(n^{\\log_b a})\\), then \\(T(n) = \\Theta(n^{\\log_b a}\\lg n)\\). If \\(f(n) = \\Omega(n^{\\log_b a + \\epsilon})\\) for some constant \\(\\epsilon \u0026gt; 0\\), and if \\(af(n/b) \\leq cf(n)\\) for some constant \\(c \u0026lt; 1\\) and all sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).  "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/shell-scripting/",
        "title": "Shell Scripting",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.08.06",
        "body": "1. Basic scripting building 1.1 Display messages Use echo to display messages.\necho \u0026#34;Hello world!\u0026#34; 1.2 Use variables Define and reference a variable.\nval=10 echo ${val} In most cases, the curly brackets can be ignored.\nval=str # ignore curly brackets echo $val # ignoring curly brackets will lead to error echo ${val}ing Define and reference an array.\na[0]=1 echo ${a[0]} # or a = (1 2 3) echo ${a[0]} Note: bash treats all values as string.\n1.3 Exit Use echo $? to check the exit status. Use exit N to return the status N.\n2. Conditional statements 2.1 if-then statements if command; then commands elif command; then commands else commands fi The commands under the then statement will be executed only if the command after if statement is a valid command and the exit status is zero.\n2.2 Testing conditions Besides commands, bash provides a way to test conditions. There are three types of conditions:\n numeric comparisons string comparisons file comparisons  Use double parentheses for numeric comparisons, including most operators in C and ** for exponentiation.\nif (( expression )); then commands fi Use double square brackets for string comparisons, including normal string operators and =~ for regular expression.\nif [[ comparison ]]; then commands fi The file comparisons are the most powerful and most used comparisons in shell scripting.\nif [ condition ]; then commands fi    Comparison Description     -e file Check if file exists   -d file Check if file exists and is a directory   -f file Check if file exists and is a file   -r file Check if file exists and is readable   -w file Check if file exists and is writable   -x file Check if file exists and is executable   -s file Check if file exists and is not empty   -O file Check if file exists and is owned by the current user   -G file Check if file exists and is owned by the current group   file1 -nt file2 Check if file1 is newer than file2   file1 -ot file2 Check if file1 is older than file2    In addition, you can combine conditions using AND (\u0026amp;\u0026amp;) and OR (||).\n2.3 case statements case variable in pattern1) commands ;; pattern2 | pattern3) commands ;; *) commands ;; esac 3. Looping statements 3.1 for statements for var in words; do commands done We can create words by brace expansion, wildcards or command substitution.\n# brace expansion for var in {a..z}; do commands done # wildcards for var in *.txt; do commands done # command substitution for var in $(command); do commands done We can change the value of IFS to change separator temporarily.\nIFS.OLD=$IFS IFS=$\u0026#39;\\n\u0026#39;:;\u0026#34; commands IFS=$IFS.OLD Bash also provides the C-style for statements.\nfor (( expression1; expression2; expression3 )); do commands done 3.2 while and until statements # while while command; do commands done # until until command; do commands done 3.3 Control the loop Two commands are used to control what happens inside of a loop:\n break continue  break n can indicate the level of the loop to break out of. By default n is 1.\n3.4 Process the output of a loop You can redirect or pipe the output of a loop within the script.\n# redirect for var in words; do commands done \u0026gt; output.txt # pipe for var in words; do commands done | grep txt 4. Handle input 4.1 Command line parameters  Use $0 to refer to the script name. Use $1, $2 and so on to refer to the command line parameters. If the number is larger than 9, use curly brackets ${n}. $# contains the number of parameters. Use ${!#} to refer the last parameter.  Both $* and $@ include all the command line parameters. The former takes all the parameters as a single word, while the latter takes all the parameters as separate words.\n4.2 Being shifty shift moves each parameter variable one position to the left by default. For example, after shift command, $3 refers to the fourth parameter, $2 refers to the third parameter, and $1 refers to the second parameter. Note that $0 always refers to the script name.\nYou can use shift to work with options.\nwhile [ -n \u0026#34;$1\u0026#34; ]; do case \u0026#34;$1\u0026#34; in -a) commands ;; *) echo \u0026#34;Error\u0026#34; ;; esac shift done Usually the Linux-style command looks like command options parameter, and some options even requre another parameters, such as\nls -a rm -rf file curl -o outputfile url In such cases, getopts is a better choice rather than shift.\ngetopts optstring opt The optstring lists all valid option characters. A colon after a character means the option requires a value. Each time it is invoked, an option is assigned in opt, and the index of next option is assigned in OPTIND. If the option requres a value, it will be stored in OPTARG. Thus OPTIND should be initialized as 1 at first. Here is an example.\nOPTIND=1 while getopts a:bc opt; do case \u0026#34;$opt\u0026#34; in a) # store value in val val=$OPTARG commands ;; b) commands ;; c) commands *) echo \u0026#34;Error\u0026#34; ;; esac done shift $(($OPTIND-1)) for var in \u0026#34;$@\u0026#34;; do commands done 4.3 Get user input There are two forms of read command:\n# form 1 echo -n question read var # form 2 read -p question var Use -t option to deal with timing out.\necho -n question if read -t seconds var; then commands else echo \u0026#34;Time out!\u0026#34; fi Use -n option to limit the input size.\n# accept only one character read -n1 var Use -s option to prevent the input from displaying on the monitor.\necho -n \u0026#34;Enter your password: \u0026#34; read -s passwd Read from file.\ncat file.txt | while read line; do commands done 5. File descriptors 5.1 Redirect to a file descriptor command \u0026gt;\u0026amp;2 5.2 Redirect a file descriptor to files exec 1\u0026gt;file1 exec 0\u0026lt;file2 5.3 Create your own file descriptors exec 3\u0026gt;file1 exec 4\u0026lt;file2 exec 5\u0026lt;\u0026gt;file3 Save the STDIN/STDOUT file descriptor location to another file descriptor temporarily to read/write a file.\nexec 3\u0026gt;\u0026amp;1 exec 1\u0026gt;file1 echo \u0026#34;hello world\u0026#34; # write to file1 exec 1\u0026gt;\u0026amp;3 echo \u0026#34;hello world\u0026#34; # write to STDOUT exec 3\u0026lt;\u0026amp;0 exec 0\u0026lt;file2 read var # read from file2 exec 0\u0026lt;\u0026amp;3 read var # read from STDIN Close file descriptors.\nexec 3\u0026gt;\u0026amp;- 6. Trap signals To trap signals in a script:\ntrap command signals # the trap can be modified trap command2 signals # also can be removed trap -- signals To trap a script exit\ntrap commands EXIT 7. Create functions 7.1 Basic script functions There are two forms to define a function.\n# form 1 function name { commands } #form 2 name() { commands } 7.2 Return a value The return statement is different from other programming languages. It return the exit status of the function. The exit status must be in the range of 0 to 255.\nfunction func { commands return 0 } func echo \u0026#34;The exit status is $?\u0026#34; To return a value like other programming languages, you can capture the output of the function.\nfunction func { commands echo output } output=$(func) 7.3 Use variables in functions The bash shell treats functions just like scripts. You can pass parameters to a function just like a regular script.\nfunction func { command } func parameters Parameters can also be passed to functions via global variables.\nvar=1 function func { var=2 } func # var=2 echo \u0026#34;var=$var\u0026#34; To avoid modifying the value defined outside functions, you can use local variables.\nvar=1 function func { local var=2 } func # var=1 echo \u0026#34;var=$var\u0026#34; 7.4 Array variables and functions Passing an array to a function is very confusing.\nfunction func { local newarray newarray=(;\u0026#39;echo \u0026#34;$@\u0026#34;\u0026#39;) echo ${newarray[*]} } myarray1=(1 2 3) myarray2=($(func $myarray1)) 7.5 Function recursion function func { commands var=$(func) commands } 7.6 Create a library To use functions defined in other script files:\nsource script_file.sh 7.7 Use functions on the command line Define functions in the .bashrc file, then you can use them in the command line.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/growth-of-functions/",
        "title": "Growth of Functions",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.07.20",
        "body": "1. Asymptotic notation \\(\\Theta\\)-notation: \\(f(n) \\in \\Theta(g(n))\\) if there exist positive constants \\(c_1, c_2, n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq c_1 g(n) \\leq f(n) \\leq c_2 g(n)]\n\\(O\\)-notation: \\(f(n) \\in O(g(n))\\) if there exist positive constants \\(c, n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq f(n) \\leq c g(n)]\n\\(\\Omega\\)-notation: \\(f(n) \\in \\Omega(g(n))\\) if there exist positive constants \\(c, n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq c g(n) \\leq f(n)]\n\\(o\\)-notation: \\(f(n) \\in o(g(n))\\) if for all positive constant \\(c\\), there exists \\(n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq f(n) \u0026lt; c g(n)]\n\\(\\omega\\)-notation: \\(f(n) \\in \\omega(g(n))\\) if for all positive constant \\(c\\), there exists \\(n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq c g(n) \u0026lt; f(n)]\n2. Standard notations and common functions 2.1 Monotonicity A function \\(f(n)\\) is monotonically increasing, if \\(m \\leq n\\) implies \\(f(m) \\leq f(n)\\).\nA function \\(f(n)\\) is monotonically decreasing, if \\(m \\leq n\\) implies \\(f(m) \\geq f(n)\\).\n2.2 Floors and ceilings [x-1 \u0026lt; \\lfloor x \\rfloor \\leq x \\leq \\lceil x \\rceil \u0026lt; x+1] [\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n] [\\left\\lceil \\frac{\\lceil x/a \\rceil}{b} \\right\\rceil = \\left\\lceil \\frac{x}{ab} \\right\\rceil] [\\left\\lfloor \\frac{\\lfloor x/a \\rfloor}{b} \\right\\rfloor = \\left\\lfloor \\frac{x}{ab} \\right\\rfloor] [\\left\\lceil \\frac{a}{b} \\right\\rceil \\leq \\frac{a+b-1}{b}] [\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\geq \\frac{a-b+1}{b}]\n2.3 Modular arithmetic The value of \\(a \\mod n\\) is the residue of the quotient \\(a/n\\).\n2.4 Polynomials A polynomial in \\(n\\) of degree \\(d\\) is a function of the form\n[p(n) = \\sum_{i=0}^d a_i n^i]\n2.5 Exponentials [f(n) = a^n]\nThe Taylor series of \\(e^x\\),\n[e^x = \\sum_{i=0}^\\infty \\frac{x^i}{i!}]\n2.6 Logarithms Denote \\(\\lg n = \\log_2 n\\) and \\(\\ln n = \\log_e n\\).\n2.7 Factorials Stirling\u0026rsquo;s approximation,\n[n! = \\sqrt{2\\pi n}(\\frac{n}{e})^n(1 + \\Theta(\\frac{1}{n}))]\n2.8 Functional iteration [f^{(i)}(n) = f(f(\\dots f(n)))]\n2.9 The iteration logarithm function [\\lg^* n = \\min \\{i : \\lg^{(i)} n \\leq 1\\}]\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/learning-linux/",
        "title": "Learning Linux",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.06.11",
        "body": "1. Basic commands Navigate the filesystem \u0026amp; manipulate directories and files.\n   name description     cd change directory   ls list   cp copy   mv move   rm remove   ln create links   mkdir create directories    View the contents of files.\n   name description     file determine file type   cat view entire contents of a file   less view entire contents of a file   head view top lines of a file   tail view bottom lines of a file    Monitor system status.\n   name description     ps show processes status   top show processes status dynamically   free show memory usage   df report file system disk space usage   du estimate file space usage    Use commands.\n   name description     man show reference manuals   which show the full path of command   type show description of command type   history show command history   alias define or display aliases    2. Run commands in shell 2.1 IO redirection Redirect output.\n# overwriting the file command \u0026gt; file # appending output to the file command \u0026gt;\u0026gt; file # suppressing output. command \u0026gt; /dev/null Redirect input.\ncommand \u0026lt; inputfile # inline input redirection command \u0026lt;\u0026lt; marker data marker There is no dedicated redirection operator for redirecting errors. We have to refer to its file descriptor. The bash shell reserves the first three file descriptors as STDIN (0), STDOUT (1) and STDERR (2).\ncommand 2\u0026gt; file Redirect both output and errors.\ncommand 1\u0026gt; file1 2\u0026gt; file2 command \u0026amp;\u0026gt; file 2.2 Pipes command1 | command2 Use tee to construct a T pipe.\n# the output of command1 will be saved to file and passed to command2 command1 | tee file | command2 Some commands can be a filter in pipes.\n   name description     sort sort lines   uniq remove duplicates   tr transliterate characters   grep pattern matching by lines   sed stream editor   awk pattern scanning and processing   wc word count    2.3 Expansion Wildcards.\n   Wildcard Meaning     * match any characters   ? match any single character   [characters] match any character in brackets   [!characters] match any character not in brackets   [[:class:]] match any character in class    Class include [[:alnum:]], [[:alpha:]], [[:digit:]], [[:lower:]] and [[:upper:]].\nPathname expansion.\n# list all txt files ls *.txt # tilde for home directory cd ~ Arithmetic expansion. It only supports integer arithmetic.\n$((expression)) # the result is 2 echo $((5/2)) Brace expansion.\n# the result is \u0026#34;file1 file2 file3\u0026#34; echo file{1,2,3} # use range echo file{1..3} # nested brace expansion # the result is \u0026#34;file13 file14 file23 file 24\u0026#34; echo file{1{3,4},2{3,4}} Variable expansion.\n$var Command substitution.\n$(command) `command` Double quoting.\n# all characters are treated as ordinary characters # except dollar sign, backslash and backquote echo \u0026#34;~ will not be expanded as home directory\u0026#34; echo \u0026#34;$varstill show the value of var\u0026#34; echo \u0026#34;backslash is used to escape special characters such as \\$\u0026#34; Single quoting.\n# suppress all expansion echo \u0026#39;$(ls)\u0026#39; 2.4 Jobs Run commands one after one.\ncommand1; command2 Commands are run in foreground mode by default. Run commands in background mode.\n# run in background command \u0026amp; # show jobs launched from current terminal jobs # return the job to foreground fg %n If you exit the terminal session, all jobs, even in background mode, will be interrupted. To avoid this, run scripts without a hang-up.\nnohup command \u0026amp; The nohup command disassociates the process from the terminal, thus it redirects STDOUT and STDERR to nohup.out file. Be careful if you run multiple commands using nohup. All output is appended to nohup.out.\nUse Ctrl+C to interrupt the current-running job. Use Ctrl+Z to stop the current running job. Usually we use Ctrl+Z to move the current-running job to background.\ncommand # stop by Ctrl+Z # show the job number jobs # move to background bg %n # or return to foreground fg %n Use kill and killall to send other signals to processes.\n3. Environment variables Linux environment variables help to store system information, temporary data and configuration information.\nDefine a environment variable.\nvariable_name=variable_value echo $variable_name Define a global environment variable.\nvariable_name=variable_value export variable_name echo $variable_name Add new path.\nPATH=$PATH:/your/new/path 4. File permissions The permission of each file is in form of -rwxrwxrwx. The first character defines the type of the file.\n - for files d for directories l for links c for character devices b for block devices n for network devices  After that define the permissions of the owner, the group owning the file, and everyone else.\n   name description     chmod change file mod bits   chown change file owner and group    5. Filesystem The default filesystem of linux is ext filesystem. The ext filesystem uses an inode system to create a inode table, to store file information, including filename, file size, the owner \u0026amp; group, file permission and pointers to disk block.\nThe ext4 filesystem, the newest ext filesystem, is a journaling filesystem. It write file changes into a temporary file first. After data is successfully written to the storage device and the inode table is updated, the journal file is deleted. Other journaling filesystems include XFS and ReiserFS.\nAn alternative to journaling is copy-on-write. For modifying data, a snapshot is used. Even when data modification is completed, the old data is never overwritten. COW filesystems include ZFS and Btrfs.\n   name description     mount mount storage devices   fdisk manipulate disk partition table   mkfs build a Linux filesystem   fsck check and repair a Linux filesystem    Linux Logical Volume Manager (LVM) is used for managing logical volumes.\n6. Utilities in Linux world 6.1 Package management system Use packege management system to install software.\n   Linux distribution Package management system     Debian dpkg/apt   Redhat rpm/yum   OpenSuse zypper   Archlinux pacman   Gentoo emerge    6.2 Network    name description     ping verify the network connection   wget network download   curl transfer a URL   ssh remote login   scp secure file copy   sftp secure file transfer    6.3 Archive    name description     tar archiving utility   gzip compress files   rsync remote file and directory synchronization    6.4 Find files    name description     touch change file timestamp   find find files   xargs transfer input to args    APPENDIX Common Linux Directory Names\n   directory Usage     / root of the virtual directory   /bin binary directory, where many GNU user-level utilities are stored   /boot boot directory   /dev device directory   /etc system configuration files directory   /home home directory   /lib library directory, where system and application library files are stored   /media media directory, a common place for mount points   /mnt mount directory, another common place for mount points   /opt optional directory, often used to store third-party software packages and data files   /proc process directory, where hardware and process information is stored   /root root home directory   /run run directory, where runtime data is held during system operation   /sbin binary directory, where many GNU admin-level utilities are stored   /srv service directory, where local services store their files   /sys system directory, where system hardware information files are stored   /tmp temporary directory   /usr user binary directory, where the bulk of GNU user-level utilities and data files are stored   /var variable directory, for files that change frequently, such as log files    Linux Process Signals\n   Signal Name Description     1 HUP Hangs up   2 INT Interrupts   3 QUIT Stops running   9 KILL Unconditionally terminates   11 SEGV Produces segment violation   15 TERM Terminates if possible   17 STOP Stops unconditionally, but doesn\u0026rsquo;t terminate   18 TSTP Stops or pauses, but continues to run in background   19 CONT Resumes execution after STOP or TSTP    "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/getting-started/",
        "title": "Getting Started",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.05.18",
        "body": "1. Insertion sort Insertion sort is implemented below.\nvoid insertion_sort(int *a, int n) { int i, j, temp; for (i = 1; i \u0026lt; n; ++i) { temp = a[i]; j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; temp) { a[j+1] = a[j]; j -= 1; } a[j+1] = temp; } return; } We use loop invariants to proof the correctness of our algorithm. A loop invariant includes three parts:\n It\u0026rsquo;s true prior to the first iteration. If it\u0026rsquo;s true before an iteration, it remain true before the next iteration. When the loop terminates, the invariant give us a useful property.  2. Analyzing algorithms The worst-case running time of insertion sort is \\(\\Theta(n^2)\\).\n3. Designing algorithms We use the idea of divide-and-conquer to design a sort algorithm, merge sort. It is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void merge(int *a, int b, int m, int e) { int i, j, k; int *a1 = (int *) malloc(sizeof(int)*(m-b+2)); for (i = b; i \u0026lt;= m; ++i) a1[i-b] = a[i]; a1[m-b+1] = 0x7FFFFFFF; int *a2 = (int *) malloc(sizeof(int)*(e-m+1)); for (j = m+1; j \u0026lt;= e; ++j) a2[j-m-1] = a[j]; a2[e-m] = 0x7FFFFFFF; i = 0; j = 0; for (k = b; k \u0026lt;= e; ++k) { if (a1[i] \u0026lt;= a2[j]) {a[k] = a1[i]; ++i;} else {a[k] = a2[j]; ++j;} } free(a1); free(a2); return; } void merge_sort_r(int *a, int b, int e) { if (e \u0026gt; b) { int m = (e + b) / 2; merge_sort(a, b, m); merge_sort(a, m+1, e); merge(a, b, m, e); } return; } void merge_sort(int *a, int n) { merge_sort_r(a, 0, n-1); return; } The worst-case running time of merge sort is \\(\\Theta(n\\log n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/the-role-of-algorithms-in-computing/",
        "title": "The Role of Algorithms in Computing",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.05.04",
        "body": "1. Algorithms An algorithm is any well-defined computational procedure. A data structure is a way to store and organize data in order to facilitate access and modifications.\n2. Algorithms as a technology Since computers are not infinitely fast, and memory is not free, efficient algorithms are important. A usual measure of efficiency is speed.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/learning-git/",
        "title": "Learning Git",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.04.16",
        "body": "1. Git Basics Initializing a repository.\ngit init Clone a repository.\ngit clone \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; Track new files or stage modified file.\ngit add \u0026lt;file\u0026gt; Remove and move files.\ngit rm \u0026lt;file\u0026gt; git mv \u0026lt;file\u0026gt; Commit all staged files.\ngit commit git commit --amend # commit to your last commit Check the status.\ngit status Show commit history.\ngit log git log --patch # show the difference Work with remotes.\ngit remote # show remotes git remote add \u0026lt;remote-name\u0026gt; \u0026lt;url\u0026gt; # add remote git remote rm \u0026lt;remote-name\u0026gt; # remove remote git remote rename \u0026lt;remote-name1\u0026gt; \u0026lt;remote-name2\u0026gt; # rename remote git fetch \u0026lt;remote-name\u0026gt; # fetch the remote git pull \u0026lt;remote-name\u0026gt; \u0026lt;branch\u0026gt; # pull = fetch and merge git push \u0026lt;remote-name\u0026gt; \u0026lt;branch\u0026gt; # push Work with tags.\ngit tag # show tags git tag -a \u0026lt;tag\u0026gt; \u0026lt;commit checksum\u0026gt; # create tag git tag -d \u0026lt;tag\u0026gt; # delete tag git push \u0026lt;remote-name\u0026gt; \u0026lt;tag\u0026gt; # push tag to remote git push \u0026lt;remote-name\u0026gt; --tags # push all tags to remote 2. Branch Git store all data as snapshots. The snapshot is organized in the form of tree structure. Each file is stored as a blob object as the leaf of the snapshot tree. If the file is not modified, git will only store a pointer to its previous blob object.\nWhen making a commit, a commit object is created, including author\u0026rsquo;s name, email, commit message, a pointer to the root node of the snapshot tree, and a pointer to its parent commit.\nBoth tags and branches are pointers to a commit object. Another important pointer is HEAD, which decide what files are shown in the current directory.\nCreate a new branch.\ngit branch \u0026lt;branch\u0026gt; Move the HEAD to point to a branch.\ngit checkout \u0026lt;branch\u0026gt; git checkout -b \u0026lt;branch\u0026gt; # create a branch and switch to it Merge a branch and delete it.\ngit merge \u0026lt;branch\u0026gt; git branch -d \u0026lt;branch\u0026gt; If the merged branch is fast-forward current branch, the command will only move current branch pointer forward. If not, the merging is based on the most recent common ancestor. A new snapshot is created and current branch pointer will be moved to the new snapshot.\nIf a merge conflict occur, git will stop merging and add conflict marker in the files that have conflicts. You have to modify manually and commit to finalize.\ngit commit When you clone a repository from Internet, there are two different pointers for each branch, one normal branch, and one remote-tracking branch. The remote-tracking branch show the branch information of the remote repository. When you commit, only the local branch pointer will move. Fetch will synchronize the remote-tracking branch pointer to the remote repository.\nAfter cloning a repository, git automatically create a local master branch tracking the remote-tracking master branch. If you want to track other branch,\ngit checkout --track \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; # if you want to have a different name git checkout -b \u0026lt;another-name\u0026gt; \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; To set a local branch to a remote-tracking branch,\ngit branch -u \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; Delete a remote branch.\ngit push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch\u0026gt; 3. Rebase Rebase command change the ancestor of a branch. It finds the common ancestor of two branches, gets all changes since the common ancestor, replays the changes to the base branch. The former branch will be deleted.\ngit rebase \u0026lt;base-branch\u0026gt; \u0026lt;topic-branch\u0026gt; Often, rebase is used when you want to contribute a project. Rebase your local branch to origin/master, and submit the pull request. It will be convenient for the maintainer to merge your changes.\nNote:\n Do not rebase commits that exist outside your repository Do not rebase commits that others may have based work on  Compared with merge, rebase will delete some history of your project, but make your project history clear.\n4. Reset and Checkout Git maintains three trees.\n HEAD: last commit snapshot, which the HEAD pointer pointing to Index: files staged and to be commit Working Directory  Reset command do three things:\n move what HEAD points to (stop here if --soft) update the Index with the contents of what HEAD points to (stop here if --mixed or no options) update the Working Directory (stop here if --hard)  Thus git reset HEAD \u0026lt;file\u0026gt; is used to unstage a staged file.\nThe main differences between reset and checkout are:\n Checkout is working-directory safe. Checkout only move the HEAD pointer, while reset move what HEAD points to.  Both reset and checkout can be followed by \u0026lt;paths\u0026gt;. Only the paths, rather than the whole directory, will be act upon.\n5. Debug Find which commit was the first one to introduce a bug or problem.\ngit bisect start git bisect bad git bisect good \u0026lt;good_commit\u0026gt; Annotate the lines with which commit was the last one to introduce a change and who authored that commit.\ngit blame -L \u0026lt;line1\u0026gt;,\u0026lt;line2\u0026gt; \u0026lt;file\u0026gt; Find any string in files, no matter current or older versions.\ngit grep \u0026lt;str\u0026gt; "
    }
]
