[
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E5%B1%B1%E5%A4%A7%E9%A3%9F%E8%AE%B0/",
        "title": "山大食记",
        "section": "posts",
        "tags": ["多余的话"],
        "date" : "2021.10.15",
        "body": "一 第一次吃山大食堂是来上大学的第二天。\n一觉醒来已经有些晚了。 我记得那天天气很好，阳光明媚，在九月初秋晒得人很舒服，我和我的高中同学阿垚一起去吃早饭。 我们是从食堂的南门进入，食堂的人很多，每个窗口排了长长的队伍。 我们随便选了一个窗口，跟着前面人，购买了人生中第一张鸡蛋饼。 打饭阿姨的旁边摞了几摞鸡蛋饼，像宝塔一样。 我们也没想到我们吃的就是日后令无数山大毕业生想念的山大鸡蛋饼。 松软的饼身里混入了点点葱花，彰显葱省味道，饼身上的鸡蛋则带来紧实的口感，鸡蛋之上则是一层酥脆的表皮。 一口下去，层次分明。 从边缘开始吃，咬到中间则是一个完整的蛋黄，丰富的蛋白质和胆固醇带来最原始的满足。\n我本以为鸡蛋饼将会是我的每日早餐，但越来越晚起床时间则压缩了去食堂的时间，直至教学楼下的手抓饼替代了鸡蛋饼。\n二 如果说再给我一次机会，让我回学校食堂吃一次饭，我一定会选二楼的石锅拌饭。\n第一次尝试石锅拌饭还是在大一下学期。 那个学期课业繁重，必修课就有33学分，在加上一门选修课，课程表排得满满当当。 上午上完第四节课再磨蹭一下，食堂的大部分窗口都没什么菜了。 二楼的石锅窗口是为数不多的选择。 米饭之上整齐地码放着西葫、豆芽和鸡肉，其上再铺一层辣酱，最后盖一个煎蛋。 用食堂的不锈钢汤匙轻轻戳破煎蛋，将蔬菜、鸡肉、辣酱和米饭拌在一起， 辣酱触碰到高温的石锅，发出嗤嗤的声响，香气也随着冒起的白烟扑入口鼻，让人食指大动。 拌匀之后一勺入口，首先是米饭混杂着煎蛋，又滑又嫩， 接着辣酱的辣味携裹着米饭和鸡蛋的香气直冲鼻腔，让人欲罢不能。 嚼上几口，则能感受到豆芽和西葫的爽脆可口。 吃过一次之后，我就成了石锅窗口的忠实食客。 下课之后，来干一碗拌饭，吃完心满意足地聊会儿天，把石锅送回窗口， 就该背起书包，去洪家楼做物理实验了。 即使到了高年级，课业逐渐轻松，在吃的方面有了更多的选择，我还是常常来二楼大快朵颐。 石锅拌饭已经成为我的默认选项，在我不知道吃什么的时候，就去二楼吃石锅拌饭。\n三 大家都说三楼的水饺很好吃，但我对水饺并不感冒，所以很少去吃。 只有在过洋节的时候突发奇想，才会去吃一次， 再配上一些诸如“俺们北方人圣诞节当然是吃饺子啦”的文案发到朋友圈。 不过有一说一，三楼的番茄鸡蛋馅儿水饺虽然听上去像黑暗料理，但吃起来真的不错。 三楼的水饺窗口还有一个功能，那就是让学生自己包饺子下饺子吃。\n我们班的团建活动屈指可数，一起包饺子算一个。 在大一的冬至，我们班就组织了包饺子活动。 食堂提供和好的面、剁好的馅儿，我们只要包就好。 说起来令人尴尬，我们一个班只有一个人能够熟练地擀饺子皮， 但总不能让一个人擀啊，那没包完饺子大家都饿死了。 于是大家各显神通，擀出的饺子皮自然千形百状。 大家包饺子的手法也不尽相同，包出来的饺子有的像笼包，有的像锅贴，就是不像饺子。 最终，这一顿水饺令大家难忘， 只是不知给我下饺子的食堂阿姨对我们的“杰作”作何感想。\n四 如果说食堂是山大生活设施的皇冠，那么一多餐厅就是这皇冠上的明珠。 如果用一个词来形容一多餐厅的话，那就是精致。 牛排意面套餐，各种煲饭，各式甜品，以及琳琅满目的菜品，应有尽有，厨师还会推出一些网红菜品，譬如路飞的大骨肉棒。 对我来说最为惊喜的是，在春天这里居然能吃的到新鲜的香椿芽。\n我从小就喜欢吃香椿芽，无论是裹着面糊炸，还是炒鸡蛋，都很美味。 但香椿的时令性很强，很快芽叶就老了不好吃了。 因此食堂香椿芽供应很不稳定，即使是春天，也时有时无，能不能吃到看运气。 运气好碰上了来上一盘，香椿的独有香气混着鸡蛋香勾着人肚里的馋虫，每次都能一扫而光。 春日暖暖的太阳，吃上一盘香椿炒蛋，给人以新的一年新气象之感， 不由得发出诸如“新的一年我一定要好好学习”的flag。\n五 有的时候头天晚上熬夜，早上起得晚但又没到午饭时间，没关系，来地下一层来一碗热粥。 有的时候因为学习、开会错过了晚饭？没事，地下一层的灯光一直为你亮着。\n大四最后一个学期，黄大哥拉我一起早起练球。球技没什么长进，但保持了很长一段时间的规律作息。 为了能六点起床，我不能熬夜，十点半就得上床准备睡觉了。 刚开始的时候还是初春，天气很冷，天也短，还蒙蒙亮，诺大的篮球场只有我们两个人。 随着天气渐暖，白昼变长，篮球场也渐渐热闹起来，我这才发现原来学校里有这么多篮球爱好者早起练球。 练完休息一下后，快九点了，我俩就去地下一层吃早饭。 吃早饭前，我一般会去前台买一瓶冰脉动一饮而尽，消解运动后的疲惫。 运动之后我一般没什么食欲，喝一碗粥，吃一点水果，新的一天就开始了。 由春入夏，天气越来越暖和，球场的人也越来越多，场地也渐渐紧张起来，有时候我们会占不到场，只能去旁边排球场练一会儿运球。 占不到场地的情况发生得越来越频繁，我们俩也就慢慢不去练球了。当然，这都是后话了。\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/dynamic-programming/",
        "title": "Dynamic Programming",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.04.15",
        "body": "1. Rod cutting Three versions of rod cutting algorithms are implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int cut_rod(int *p, int n) { if (n == 0) return 0; int i, q = -0x7fffffff; for (i = 0; i \u0026lt; n; ++i) { int temp_q = p[i] + cut_rod(p, n-i-1); q = temp_q \u0026gt; q ? temp_q : q; } return q; } int memoized_cut_rod_aux(int *p, int n, int *r) { if (n == 0) return 0; if (r[n-1] \u0026gt;= 0) return r[n-1]; int i, q = -0x7fffffff; for (i = 0; i \u0026lt; n; ++i) { int temp_q = p[i] + memoized_cut_rod_aux(p, n-i-1, r); q = temp_q \u0026gt; q ? temp_q : q; } r[n-1] = q; return q; } int memoized_cut_rod(int *p, int n) { int i, *r = malloc(sizeof(int)*n); for (i = 0; i \u0026lt; n; ++i) r[i] = -0x7fffffff; int result = memoized_cut_rod_aux(p, n, r); free(r); return result; } int bottom_up_cut_rod(int *p, int n) { int i, j, *r = malloc(sizeof(int)*n); for (i = 0; i \u0026lt; n; ++i) { int q = -0x7fffffff; for (j = 0; j \u0026lt;= i; ++j) { int temp_q = j == i ? p[j] : p[j] + r[i-j-1]; q = temp_q \u0026gt; q ? temp_q : q; } r[i] = q; } int result = r[n-1]; free(r); return result; } 2. Matrix-chain multiplication Four steps to use dynamic programming:\n Characterize the structure of an optimal solution. Recursively define the value of an optimal solution. Compute the value of an optimal solution. Construct an optimal solution from computed information.  3. Elements of dynamic programming There are two key ingredients that an optimization problem must in order for dynamic programming to apply:\n Optimal substructure: an optimal solution contains within it optimal solution to subproblems. Overlapping subproblems: a recursive algorithm revisits the same subproblems repeatly.  4. Longest common subsequence A program to find the longest common subsequence of two strings is implemented below.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; void lcs_length(char *x, int nx, char *y, int ny, int *c, int *aux_c) { int i, j; for (i = 0; i \u0026lt;= nx; ++i) c[i*(ny+1)] = 0; for (j = 0; j \u0026lt;= ny; ++j) c[j] = 0; for (i = 1; i \u0026lt;= nx; ++i) for (j = 1; j \u0026lt;= ny; ++j) if (x[i-1] == y[j-1]) { c[i*(ny+1)+j] = c[(i-1)*(ny+1)+(j-1)] + 1; aux_c[i*(ny+1)+j] = 0; } else if (c[i*(ny+1)+(j-1)] \u0026gt; c[(i-1)*(ny+1)+j]) { c[i*(ny+1)+j] = c[i*(ny+1)+(j-1)]; aux_c[i*(ny+1)+j] = -1; } else { c[i*(ny+1)+j] = c[(i-1)*(ny+1)+j]; aux_c[i*(ny+1)+j] = 1; } return; } void print_lcs_aux(char *y, int ny, int *aux_c, int i, int j) { if (i == 0 || j == 0) return; if (aux_c[i*(ny+1)+j] == 0) { print_lcs_aux(y, ny, aux_c, i-1, j-1); printf(\u0026#34;%c\u0026#34;, y[j-1]); } else if (aux_c[i*(ny+1)+j] == 1) print_lcs_aux(y, ny, aux_c, i-1, j); else print_lcs_aux(y, ny, aux_c, i, j-1); return; } void print_lcs(char *x, int nx, char *y, int ny) { int *c = malloc(sizeof(int)*(nx+1)*(ny+1)); int *aux_c = malloc(sizeof(int)*(nx+1)*(ny+1)); lcs_length(x, nx, y, ny, c, aux_c); print_lcs_aux(y, ny, aux_c, nx, ny); printf(\u0026#34;\\n\u0026#34;); free(c); free(aux_c); return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/augmenting-data-structures/",
        "title": "Augmenting Data Structures",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.04.08",
        "body": "1. Dynamic order statistics Via adding a new attribute size in a red-black tree, we can determine any order statistic in \\(O(n)\\) time. The size refer to the number of nodes of the subtree whose root is the node. It is called order-statistic tree.\n2. How to augment a data structure  Choose an underlying data structure. Determine additional information to maintain in the underlying data structure. Verify that we can maintain the additional information for the basic modifying operations on the underlying data structure. Develop new operations.  "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E5%BC%A0%E5%A4%A7%E8%B7%AF%E4%BC%A0%E5%A5%87/",
        "title": "张大路传奇",
        "section": "posts",
        "tags": ["多余的话"],
        "date" : "2021.04.05",
        "body": "张大路的名字叫张大路。 “大路”的意思就是很马虎，甚至有些糊涂，无论对什么事都不在乎。\n张大路喜欢网上冲浪。 他点开了第一篇帖子，叫做《 北京第一代“鸡娃”给大家讲讲内卷教育的切肤之痛 》， 讲的是一位北京女孩从小被妈妈”鸡“， 上辅导班，参加跨区招生考试， 高中的时候发表文章，去美国交换， 最终考上了北京电影学院导演系，当上编剧、作者的故事。 舞文弄墨，靠写一点东西来养活自己，是张大路从小的梦想。 要是在混一口饭之余，还能有钱买几本书读，那就更好了。 但是张大路并不擅长写作，他费劲脑汁蹦出的几个字并没有人愿意读， 扔到垃圾堆里也要被分类成有害垃圾。 张大路很羡慕能靠写作谋生的人。 人家是北儿京儿人儿，资源好，文字又很有灵性，高中就能发表文章， 自己怎么和人家比呢，张大路这样安慰自己。\n张大路点开了第二篇帖子，《 太苦了，听说这位自动化所的博士在工业界， 我一个男的看都想给他一个拥抱 》。 贴子是一位穷苦出身的男孩的博士论文致谢， 讲述了自己求学之路的经历。 帖子的主角跟随自动化所的一名九袋长老学习机器翻译， 并进入工业界继续在该领域发光发热。 这让张大路的内心十分羡慕。 张大路也梦想过研究机器翻译。 在发现自己的写作之路走不通后， 张大路觉得自己狗嘴吐不出象牙，那可不可以做翻译呢？ 把他国的象牙翻译成中国的象牙，也算是功德一件。 但张大路的外文也不好，他的全国大学生六级考试只有484分。 看上去张大路的翻译之路也要断绝了， 但是随着神经网络[1, 2]和attention机制[3]的发展， 机器翻译的质量发生了翻天覆地的飞跃。 去研究机器翻译似乎是一种曲线救国的路线呢，张大路这样想道。 目前国内机器翻译研究水平最高的就是该就职于自动化所的九袋长老。 张大路发现自己的一位亲戚居然也就职于自动化所， 就想托亲戚的关系套一下瓷。 就在这临门一脚的时刻，张大路自己却耸了，觉得自己配不上拜九袋长老为师。 后来又一次偶然的机会，张大路又去蹭了本校一位长老开设的高性能计算讲坛, 发现讲坛的内容对机器翻译所依赖的GPU计算的调优大有裨益， 研究一下高性能计算，可以说是曲线救国的曲线救国。 于是又想跟随该长老继续学习，却因编程经验不足而被拒绝。 当然，在仔细研究了神经机器翻译的原理后， 张大路觉得这种基于“编码-解码”的过程不能称之为翻译， 又不想做机器翻译了，这是后话了。\n张大路是学过数学分析的， 亲眼目睹两个人过上了自己的梦想（或者曾经的）人生， 一个家境优渥，一个出身困苦， 根据夹逼定理，自己也应该过着差不多的人生啊，为什么自己混成了现在这样子呢？\n张大路是学习金融数学的，曾经立志做一名quant在墙街呼风唤雨。 做quant编程是免不了的，张大路却在学习期间发现，编程真是太有趣了， 自己为什么不做一名coder呢？ 在大三的暑假，张大路郑重地决定，我要考计算机的研究生。 整个大三暑假，张大路都在阅读《算法导论》。 他看着红黑树左转又右转，插入又删除，把自己都看晕了。 张大路不禁问自己，自己这几斤几两真的能行吗？ 还好之前抱大腿，混了一个保研名额，要不先在本校读个研究生，再图后计。 于是张大路读了本校的研究生。 张大路继续磨练自己的编程手艺，以图他日投身coding事业。 就在张大路准备找实习的时候，一个出国读博的机会跳到了他的面前， 还是当前最火的机器学习方向。 送到嘴边的肥肉总不能不吃啊，张大路想道。 于是张大路去了国外读博。 回顾自己的前半生，张大路不禁感慨道，自己真是人如其名啊。 张大路的一生，是大路的一生。 从金融数学转专业计算机，放弃考研，出国读博， 每一步选择都太随意，被一时头脑发热所支配。 过于随意的选择，以及自身的懒惰，导致张大路的人生跳出了夹逼。\n张大路不是一个怨天尤人的人。 张大路拿起枕边的《欢乐英雄》，读起了郭大路的故事。 郭大路去做镖师，却把押运的银子分给了劫路的强盗。 郭大路去做厨子，把糖醋鱼摔到了客人的脸上。 郭大路去卖艺，却一套开山功，一招扫堂腿，把观众都吓跑了。 哈哈，真滑稽！张大路不禁笑了起来。 “他们懂得生命是可贵的，也懂得如何去享受生命。” 张大路一字一字地念着， “这一生中，他们做了许多出人意料、令人倒绝的事。 你也许会认为他们做的事很愚蠢，很可笑。 但你却不能不承认，他们做的事别人做不到。 你也做不到，所以你一定喜欢听他们的故事。”\n参考文献\n[1] Ilya Sutskever, Oriol Vinyals, and Quoc V. Le. 2014. Sequence to Sequence Learning with Neural Networks. In Proceedings of NIPS 2014.\n[2] Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. 2015. Neural Machine Translation by Jointly Learning to Align and Translate. In Proceedings of ICLR 2015.\n[3] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2017. Attention is All You Need. In Proceedings of NIPS 2017.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/red-black-trees/",
        "title": "Red-Black Trees",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.04.01",
        "body": "1. Properties of red-black trees A red-black tree is a binary search tree with one extra attribute per node: its color, which can be either RED or BLACK.\nAs a matter of convenience, we introduce a single sentinel and all leaf nodes point to this sentinel. A red-black tree satisfies the following properties:\n Every node is either red or black. The root is black. The sentinel is black. If a node is red, then both its children are black. For each node, all simple paths from the node to the sentinel contain the same number of black nodes.  Thus red-black trees ensure that no such path is more than twice as long as any other, so that the tree is balanced. A red-black tree with \\(n\\) nodes has height at most \\(2\\log(n+1)\\).\n2. Rotation, insertion and deletion To keep the properties while insertion and deletion, new operation rotation is necessary.\nAn interger red-black tree is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; struct object { int key; char color; struct object *p, *left, *right; }; struct red_black_tree { struct object *root, *sentinel; }; /*********** * search * ***********/ struct object *rb_tree_search(struct object *x, int k) { if (x == NULL || k == x-\u0026gt;key) return x; if (k \u0026lt; x-\u0026gt;key) return rb_tree_search(x-\u0026gt;left, k); else return rb_tree_search(x-\u0026gt;right, k); } struct object *rb_tree_min(struct object *x) { while (x-\u0026gt;left != NULL) x = x-\u0026gt;left; return x; } struct object *rb_tree_max(struct object *x) { while (x-\u0026gt;right != NULL) x = x-\u0026gt;right; return x; } struct object *rb_tree_successor(struct object *x) { if (x-\u0026gt;right != NULL) return rb_tree_min(x-\u0026gt;right); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;right) {x = y; y = y-\u0026gt;p;} return y; } struct object *rb_tree_predecessor(struct object *x) { if (x-\u0026gt;left != NULL) return rb_tree_max(x-\u0026gt;left); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;left) {x = y; y = y-\u0026gt;p;} return y; } /************* * rotation * *************/ void left_rotate(struct red_black_tree *T, struct object *x) { struct object *y = x-\u0026gt;right; x-\u0026gt;right = y-\u0026gt;left; if (y-\u0026gt;left != T-\u0026gt;sentinel) y-\u0026gt;left-\u0026gt;p = x; y-\u0026gt;p = x-\u0026gt;p; if (x-\u0026gt;p == T-\u0026gt;root) T-\u0026gt;root = y; else if (x-\u0026gt;p-\u0026gt;left == x) x-\u0026gt;p-\u0026gt;left = y; else x-\u0026gt;p-\u0026gt;right = y; y-\u0026gt;left = x; x-\u0026gt;p = y; return; } void right_rotate(struct red_black_tree *T, struct object *x) { struct object *y = x-\u0026gt;left; x-\u0026gt;left = y-\u0026gt;right; if (y-\u0026gt;right != T-\u0026gt;sentinel) y-\u0026gt;right-\u0026gt;p = x; y-\u0026gt;p = x-\u0026gt;p; if (x-\u0026gt;p == T-\u0026gt;root) T-\u0026gt;root = y; else if (x-\u0026gt;p-\u0026gt;left == x) x-\u0026gt;p-\u0026gt;left = y; else x-\u0026gt;p-\u0026gt;right = y; y-\u0026gt;right = x; x-\u0026gt;p = y; return; } /************** * insertion * **************/ void rb_insert_fixup(struct red_black_tree *T, struct object *z) { while (z-\u0026gt;p-\u0026gt;color == \u0026#39;r\u0026#39;) { if (z-\u0026gt;p == z-\u0026gt;p-\u0026gt;p-\u0026gt;left) { struct object *y = z-\u0026gt;p-\u0026gt;p-\u0026gt;right; if (y-\u0026gt;color == \u0026#39;r\u0026#39;) { z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; y-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; z = z-\u0026gt;p-\u0026gt;p; } else { if (z == z-\u0026gt;p-\u0026gt;right) { z = z-\u0026gt;p; left_rotate(T, z); } z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; right_rotate(T, z-\u0026gt;p-\u0026gt;p); } } else { struct object *y = z-\u0026gt;p-\u0026gt;p-\u0026gt;left; if (y-\u0026gt;color == \u0026#39;r\u0026#39;) { z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; y-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; z = z-\u0026gt;p-\u0026gt;p; } else { if (z == z-\u0026gt;p-\u0026gt;left) { z = z-\u0026gt;p; right_rotate(T, z); } z-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; z-\u0026gt;p-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; left_rotate(T, z-\u0026gt;p-\u0026gt;p); } } } return; } void rb_insert(struct red_black_tree *T, struct object *z) { struct object *x = T-\u0026gt;root, *y = T-\u0026gt;sentinel; while (x != T-\u0026gt;sentinel) { y = x; if (z-\u0026gt;key \u0026lt; x-\u0026gt;key) x = x-\u0026gt;left; else x = x-\u0026gt;right; } z-\u0026gt;p = y; if (y == T-\u0026gt;sentinel) T-\u0026gt;root = z; else if (z-\u0026gt;key \u0026lt; y-\u0026gt;key) y-\u0026gt;left = z; else y-\u0026gt;right = z; z-\u0026gt;left = T-\u0026gt;sentinel; z-\u0026gt;right = T-\u0026gt;sentinel; z-\u0026gt;color = \u0026#39;r\u0026#39;; rb_insert_fixup(T, z); return; } /************* * deletion * *************/ void rb_transplant(struct red_black_tree *T, struct object *u, struct object *v) { if (u-\u0026gt;p == T-\u0026gt;sentinel) T-\u0026gt;root = v; else if (u == u-\u0026gt;p-\u0026gt;left) u-\u0026gt;p-\u0026gt;left = v; else u-\u0026gt;p-\u0026gt;right = v; v-\u0026gt;p = u-\u0026gt;p; return; } void rb_delete_fixup(struct red_black_tree *T, struct object *x) { struct object *w; while (x != T-\u0026gt;sentinel \u0026amp;\u0026amp; x-\u0026gt;color == \u0026#39;b\u0026#39;) { if (x == x-\u0026gt;p-\u0026gt;left) { w = x-\u0026gt;p-\u0026gt;right; if (w-\u0026gt;color == \u0026#39;r\u0026#39;) { w-\u0026gt;color = \u0026#39;b\u0026#39;; x-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; left_rotate(T, x-\u0026gt;p); w = x-\u0026gt;p-\u0026gt;right; } if (w-\u0026gt;left-\u0026gt;color == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;color = \u0026#39;r\u0026#39;; x = x-\u0026gt;p; } else { if (w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;left-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;color = \u0026#39;r\u0026#39;; right_rotate(T, w); x = x-\u0026gt;p-\u0026gt;right; } w-\u0026gt;color = x-\u0026gt;p-\u0026gt;color; x-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;right-\u0026gt;color = \u0026#39;b\u0026#39;; left_rotate(T, x-\u0026gt;p); x = T-\u0026gt;root; } } else { w = x-\u0026gt;p-\u0026gt;left; if (w-\u0026gt;color == \u0026#39;r\u0026#39;) { w-\u0026gt;color = \u0026#39;b\u0026#39;; x-\u0026gt;p-\u0026gt;color = \u0026#39;r\u0026#39;; right_rotate(T, x-\u0026gt;p); w = x-\u0026gt;p-\u0026gt;left; } if (w-\u0026gt;left-\u0026gt;color == \u0026#39;b\u0026#39; \u0026amp;\u0026amp; w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;color = \u0026#39;r\u0026#39;; x = x-\u0026gt;p; } else { if (w-\u0026gt;right-\u0026gt;color == \u0026#39;b\u0026#39;) { w-\u0026gt;left-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;color = \u0026#39;r\u0026#39;; left_rotate(T, w); x = x-\u0026gt;p-\u0026gt;left; } w-\u0026gt;color = x-\u0026gt;p-\u0026gt;color; x-\u0026gt;p-\u0026gt;color = \u0026#39;b\u0026#39;; w-\u0026gt;right-\u0026gt;color = \u0026#39;b\u0026#39;; right_rotate(T, x-\u0026gt;p); x = T-\u0026gt;root; } } } x-\u0026gt;color = \u0026#39;b\u0026#39;; return; } void rb_delete(struct red_black_tree *T, struct object *z) { struct object *x, *y; y = z; char y_original_color = y-\u0026gt;color; if (z-\u0026gt;left == T-\u0026gt;sentinel) { x = z-\u0026gt;right; rb_transplant(T, z, z-\u0026gt;right); } else if (z-\u0026gt;right == T-\u0026gt;sentinel) { x = z-\u0026gt;left; rb_transplant(T, z, z-\u0026gt;left); } else { y = rb_tree_min(z-\u0026gt;right); y_original_color = y-\u0026gt;color; x = y-\u0026gt;right; if (y-\u0026gt;p != z) { rb_transplant(T, y, y-\u0026gt;right); y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;p = y; } rb_transplant(T, z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;p = y; y-\u0026gt;color = z-\u0026gt;color; } if (y_original_color == \u0026#39;b\u0026#39;) rb_delete_fixup(T, x); return; } 3. Other balanced search trees The idea of balancing a search tree is due to AVL trees in 1962. Another class of search trees, called 2-3 trees was introduced in 1970. Skip lists provide an alternative to balanced search trees.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/binary-search-trees/",
        "title": "Binary Search Trees",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.30",
        "body": "What is a binary search tree? A binary search tree is organized in a binary tree. The tree is represented by a linked data structure in which each node is an object. In addition to a key and satellite data, each object contains 3 more attributes: left, right and parent\nThe keys in a binary search tree are always stored in such a way as to satify that for each node in a binary search tree, the key of any node in its left subtree is smaller than its own key, and the key of any node in its right subtree is larger than its own key,\nQuerying a binary search tree Besides the SEARCH operation, binary search trees support queries as MINIMUM, MAXIMUM, SUCCESSOR and PREDECESSOR.\nInsertion and deletion To insert a new element to a binary search tree is relatively straightforward, but handling deletion when the node has both two children is somewhat more intricate.\nAn interger binary search tree is implemented below.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; struct object { int key; struct object *p, *left, *right; }; struct binary_search_tree { struct object *root; }; void inorder_tree_walk(struct object *x) { if (x != NULL) { inorder_tree_walk(x-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, x-\u0026gt;key); inorder_tree_walk(x-\u0026gt;right); } printf(\u0026#34;\\n\u0026#34;); return; } /*********** * search * ***********/ struct object *tree_search(struct object *x, int k) { if (x == NULL || k == x-\u0026gt;key) return x; if (k \u0026lt; x-\u0026gt;key) return tree_search(x-\u0026gt;left, k); else return tree_search(x-\u0026gt;right, k); } struct object *tree_min(struct object *x) { while (x-\u0026gt;left != NULL) x = x-\u0026gt;left; return x; } struct object *tree_max(struct object *x) { while (x-\u0026gt;right != NULL) x = x-\u0026gt;right; return x; } struct object *tree_successor(struct object *x) { if (x-\u0026gt;right != NULL) return tree_min(x-\u0026gt;right); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;right) {x = y; y = y-\u0026gt;p;} return y; } struct object *tree_predecessor(struct object *x) { if (x-\u0026gt;left != NULL) return tree_max(x-\u0026gt;left); struct object *y = x-\u0026gt;p; while (y != NULL \u0026amp;\u0026amp; x == y-\u0026gt;left) {x = y; y = y-\u0026gt;p;} return y; } /************** * insertion * **************/ void tree_insert(struct binary_search_tree *T, struct object *z) { struct object *x = T-\u0026gt;root, *y = NULL; while (x != NULL) { y = x; if (z-\u0026gt;key \u0026lt; x-\u0026gt;key) x = x-\u0026gt;left; else x = x-\u0026gt;right; } z-\u0026gt;p = y; if (y == NULL) T-\u0026gt;root = z; else if (z-\u0026gt;key \u0026lt; y-\u0026gt;key) y-\u0026gt;left = z; else y-\u0026gt;right = z; return; } /************* * deletion * *************/ void transplant(struct binary_search_tree *T, struct object *u, struct object *v) { if (u-\u0026gt;p == NULL) T-\u0026gt;root = v; else if (u == u-\u0026gt;p-\u0026gt;left) u-\u0026gt;p-\u0026gt;left = v; else u-\u0026gt;p-\u0026gt;right = v; if (v != NULL) v-\u0026gt;p = u-\u0026gt;p; return; } void tree_delete(struct binary_search_tree *T, struct object *z) { if (z-\u0026gt;left == NULL) transplant(T, z, z-\u0026gt;right); else if (z-\u0026gt;right == NULL) transplant(T, z, z-\u0026gt;left); else { struct object *y = tree_min(z-\u0026gt;right); if (y-\u0026gt;p != z) { transplant(T, y, y-\u0026gt;right); y-\u0026gt;right = z-\u0026gt;right; y-\u0026gt;right-\u0026gt;p = y; } transplant(T, z, y); y-\u0026gt;left = z-\u0026gt;left; y-\u0026gt;left-\u0026gt;p = y; } } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/hash-tables/",
        "title": "Hash Tables",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.28",
        "body": "1. Direct-address tables To represent a dynamic set in which the keys are drawn from a small universe, we use a direct-address table, in which each slot corresponds to a key in the universe.\n2. Hash tables Hash tables is similar to direct-address tables. With direct addressing, an element with key \\(k\\) is stored in slot \\(k\\). With hashing, an element with key \\(k\\) is stored in slot \\(h(k)\\), where \\(h\\) is a hash function.\nHowever, two keys may hash to the same slot. We call this situation a collision. The simplest collision resolution technique is chaining. We place all elements that hash to the same slot into a linked list. Given a hash table with \\(m\\) slots storing \\(n\\) elements, a search takes average-case time \\(\\Theta(1+n/m)\\).\n3. Hash functions To map a key \\(k\\) into one of \\(m\\) slots, the hash function of division method is\n[h(k) = k \\mod m,]\nand that of multiplication method is\n[h(k) = \\lfloor m(kA \\mod 1) \\rfloor,]\nwhere \\(0 \u0026lt; A \u0026lt; 1\\).\nUniversal hashing is to choose the hash function randomly in a way that is independent of the keys that are actually going to be stored.\nAn integer hash table with chaining and division hash function is implemented below.\n#include \u0026lt;stdlib.h\u0026gt;#define HASH_TABLE_SIZE 1024  struct object { int key; struct object *prev, *next; }; struct hash_table { struct object *T[HASH_TABLE_SIZE]; }; struct object *hash_search(struct hash_table *h, int k) { int index = k / HASH_TABLE_SIZE; struct object *re = h-\u0026gt;T[index]; while (re != NULL \u0026amp;\u0026amp; re-\u0026gt;key != k) re = re-\u0026gt;next; return re; } void hash_insert(struct hash_table *t, struct object *x) { int index = x-\u0026gt;key / HASH_TABLE_SIZE; x-\u0026gt;next = t-\u0026gt;T[index]; if (t-\u0026gt;T[index] != NULL) t-\u0026gt;T[index]-\u0026gt;prev = x; x-\u0026gt;prev = NULL; t-\u0026gt;T[index] = x; return; } void hash_delete(struct hash_table *h, struct object *x) { int index = x-\u0026gt;key / HASH_TABLE_SIZE; if (x-\u0026gt;prev != NULL) x-\u0026gt;prev-\u0026gt;next = x-\u0026gt;next; else h-\u0026gt;T[index] = x-\u0026gt;next; if (x-\u0026gt;next != NULL) x-\u0026gt;next-\u0026gt;prev = x-\u0026gt;prev; return; } 4. Open addressing Another collision resolution technique is open addressing. In open addressing, each table entry contains an element, NULL or DELETED. To insert an element, we probe the table until finding an empty slot. The probe sequence is generated by a hash function,\n[\\{h(k, 0), h(k, 1), \\dots, h(k, m-1)\\},]\nand is required to be a permutation. To search an element, we probe the table until finding the element or a NULL. To delete an element, we mark the corresponding slot with DELETED.\nThere are three commonly used techniques to compute the probe sequence.\n Linear probing: \\(h(k, i) = (h'(k) + i) \\mod m\\), Quadratic probing: \\(h(k, i) = (h'(k) + c_1i + c_2i^2) \\mod m\\), Double hashing: \\(h(k, i) = (h'(k) + h''(k)) \\mod m\\),  where \\(h'(k), h''(k)\\) are ordinary hash functions.\nLet \\(\\alpha = n/m\\), the expected number of probes in an unsuccessful search is \\(1/(1-\\alpha)\\), and that in a successful search is \\(\\frac{1}{\\alpha} \\ln \\frac{1}{1-\\alpha}\\).\n5. Perfect hashing If the set of keys is static, \\(O(1)\\) memory accesses can be satisfied with perfect hashing technique. The structure is similar to hash tables with chaining. Instead of making a linked list of the keys hashing to the same slot, we use a small secondary hash table. By choosing the hash function carefully, we can guarantee that there are no collisions.\nThe size of the secondary hash table is the square of the number of keys hashing to this slot. However the total size of hash table is \\(O(n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/elementary-data-structures/",
        "title": "Elementary Data Structures",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.17",
        "body": "1. Stacks and queues Stacks and queues are dynamic sets. The stack implements a last-in, first-out policy, while the queue implements a first-in, first-out policy.\nAn integer stack of size 1024 is implemented below.\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; struct stack { int a[1024]; int top; }; void push(struct stack *s, int x) { if (s-\u0026gt;top == 1023) { fprintf(stderr, \u0026#34;Overflow!\\n\u0026#34;); exit(1); } ++s-\u0026gt;top; s-\u0026gt;a[s-\u0026gt;top] = x; return; } int pop(struct stack *s) { if (s-\u0026gt;top == -1) { fprintf(stderr, \u0026#34;Underflow!\\n\u0026#34;); exit(1); } --s-\u0026gt;top; return s-\u0026gt;a[s-\u0026gt;top+1]; } An integer queue of size 1024 is implemented below.\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; struct queue { int a[1024]; int head, tail; }; void enqueue(struct queue *q, int x) { q-\u0026gt;a[q-\u0026gt;tail] = x; q-\u0026gt;tail = (q-\u0026gt;tail + 1) % 1024; if (q-\u0026gt;tail == q-\u0026gt;head) { fprintf(stderr, \u0026#34;Overflow!\\n\u0026#34;); exit(1); } return; } int dequeue(struct queue *q) { if (q-\u0026gt;head == q-\u0026gt;tail) { fprintf(stderr, \u0026#34;Underflow!\\n\u0026#34;); exit(1); } int x = q-\u0026gt;a[q-\u0026gt;head]; q-\u0026gt;head = (q-\u0026gt;head + 1) % 1024; return x; } 2. Linked lists A linked list is a linear-arranged data structure in which the order is determined by a pointer in each object.\nAn integer double linked list with a sentinel is implemented below.\nstruct object { int key; struct object *prev, *next; }; struct linked_list { struct object *sentinel; }; struct object* list_search(struct linked_list *L, int k) { struct object *re = L-\u0026gt;sentinel-\u0026gt;next; while (re != L-\u0026gt;sentinel \u0026amp;\u0026amp; re-\u0026gt;key != k) re = re-\u0026gt;next; return re; } void list_insert(struct linked_list *L, struct object *x) { x-\u0026gt;next = L-\u0026gt;sentinel-\u0026gt;next; L-\u0026gt;sentinel-\u0026gt;next-\u0026gt;prev = x; x-\u0026gt;prev = L-\u0026gt;sentinel; L-\u0026gt;sentinel-\u0026gt;next = x; return; } void list_delete(struct linked_list *L, struct object *x) { x-\u0026gt;prev-\u0026gt;next = x-\u0026gt;next; x-\u0026gt;next-\u0026gt;prev = x-\u0026gt;prev; return; } 3. Implementing pointers and objects We can use three arrays to implement a double linked list. For an index i, key[i], next[i] and prev[i] represent an object in the double linked list.\nA single array can also be used to implement a linked list just like how operating systems manage the computer memory. We can use a linked list with only next attribute to implement a stack, which we call the free list, to record which objects are free.\n4. Representing rooted trees The representation of a binary is just like that of a linked list. The difference is objects of trees have two childs.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/medians-and-order-statistics/",
        "title": "Medians and Order Statistics",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.03.01",
        "body": "The \\(i\\)th order statistic of a set of \\(n\\) elements is the \\(i\\)th smallest element.\nA selection problem is to select the \\(i\\)th order statistic from a set of \\(n\\) distinct numbers.\n1. Minimum and maximum Every element except the winner must lose once in a comparison. Hence \\(n-1\\) comparisions are necessary to determine the minimum. The algorithm is implemented below.\nint minimum(int *a, int n) { int i, min = a[0]; for (i = 1; i \u0026lt; n; ++i) if (min \u0026gt; a[i]) min = a[i]; return min; } If we want to find the minimum and maximum simultaneously, only \\(3\\lfloor n/2 \\rfloor\\) comparisions are necessary. The algorithm is implemented below.\nvoid min_and_max(int *a, int n, int *mm) { int i = (n % 2 == 1)?1:0; mm[0] = a[0]; mm[1] = a[0]; for (; i \u0026lt; n-1; i += 2) if (a[i] \u0026lt; a[i+1]) { if (a[i] \u0026lt; mm[0]) mm[0] = a[i]; if (a[i+1] \u0026gt; mm[1]) mm[1] = a[i+1]; } else { if (a[i+1] \u0026lt; mm[0]) mm[0] = a[i+1]; if (a[i] \u0026gt; mm[1]) mm[1] = a[i]; } return; } 2. Selection in expected linear time The randomized select algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int partition(int *a, int b, int e) { int ae = a[e]; int i = b - 1, j = b; for (; j \u0026lt; e; ++j) { if (a[j] \u0026lt;= ae) { ++i; int temp = a[i]; a[i] = a[j]; a[j] = temp; } } a[e] = a[i+1]; a[i+1] = ae; return i + 1; } int randomized_partition(int *a, int b, int e) { int i = rand() % (e - b + 1) + b; int temp = a[i]; a[i] = a[e]; a[e] = temp; return partition(a, b, e); } int randomized_select_r(int *a, int b, int e, int i) { if (b == e) return a[b]; int m = randomized_partition(a, b, e); if (i == m - b) return a[b]; else if (i \u0026lt; m - b) return randomized_select_r(a, b, m-1, i); else return randomized_select_r(a, m+1, e, i-(m-b)-1); } int randomized_select(int *a, int n, int i) { return randomized_select_r(a, 0, n-1, i); } The worst-case running time is \\(\\Theta(n^2)\\). If the elements are distinct, the expected running time is \\(O(n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/sorting-in-linear-time/",
        "title": "Sorting in Linear Time",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.26",
        "body": "1. Lower bounds for sorting Any comparision sort algorithm requires \\(\\Omega(n \\log n)\\) comparisions int the worst case.\n2. Counting sort The counting sort algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void counting_sort(int *a, int n, int k) { int *b = (int *) malloc(sizeof(int)*n); int *c = (int *) malloc(sizeof(int)*k); int i; for (i = 0; i \u0026lt; k; ++i) c[i] = 0; for (i = 0; i \u0026lt; n; ++i) ++c[a[i]]; for (i = 1; i \u0026lt; k; ++i) c[i] += c[i-1]; for (i = n-1; i \u0026gt;= 0; --i) { b[c[a[i]]-1] = a[i]; --c[a[i]]; } for (i = 0; i \u0026lt; n; ++i) a[i] = b[i]; free(b); free(c); return; } 3. Radix sort The radix sort algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void radix_sort(int *a, int n, int d) { int *b = (int *) malloc(sizeof(int)*n); int *c = (int *) malloc(sizeof(int)*10); int i, j, e = 1; for (i = 0; i \u0026lt; d; ++i) { for (j = 0; j \u0026lt; 10; ++j) c[j] = 0; for (j = 0; j \u0026lt; n; ++j) ++c[a[j]/e%10]; for (j = 1; j \u0026lt; 10; ++j) c[j] += c[j-1]; for (j = n-1; j \u0026gt;= 0; --j) { b[c[a[j]/e%10]-1] = a[j]; --c[a[j]/e%10]; } for (j = 0; j \u0026lt; n; ++j) a[j] = b[j]; e *= 10; } free(b); free(c); return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/quicksort/",
        "title": "Quicksort",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.26",
        "body": "1. Description of quicksort The quicksort algorithm is implemented below.\nint partition(int *a, int b, int e) { int ae = a[e]; int i = b - 1, j = b; for (; j \u0026lt; e; ++j) { if (a[j] \u0026lt;= ae) { ++i; int temp = a[i]; a[i] = a[j]; a[j] = temp; } } a[e] = a[i+1]; a[i+1] = ae; return i + 1; } void quicksort_r(int *a, int b, int e) { if (b \u0026lt; e) { int m = partition(a, b, e); quicksort_r(a, b, m-1); quicksort_r(a, m+1, e); } return; } void quicksort(int *a, int n) { quicksort_r(a, 0, n-1); return; } 2. Performance of quicksort The worst-case behavior occurs when the partitioning routine produces one subproblem with \\(n-1\\) elements and one with 0 elements. And the running time is \\(\\Theta(n^2)\\).\nThe expected running time is \\(\\Theta(n\\log n)\\).\n3. A randomized version of quicksort The randomized_quicksort algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int randomized_partition(int *a, int b, int e) { int i = rand() % (e - b + 1) + b; int temp = a[i]; a[i] = a[e]; a[e] = temp; return partition(a, b, e); } void randomized_quicksort_r(int *a, int b, int e) { if (b \u0026lt; e) { int m = partition(a, b, e); randomized_quicksort_r(a, b, m-1); randomized_quicksort_r(a, m+1, e); } return; } void randomized_quicksort(int *a, int n) { randomized_quicksort_r(a, 0, n-1); return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/heapsort/",
        "title": "Heapsort",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.24",
        "body": "1. Heaps The heap data structure is an array that can be viewed as nearly complete binary tree. The tree is completely filled on all levels except possibly the lowest, which is filled from the left up to a point. The parent index of the \\(i\\)th element is \\(\\lceil i/2 \\rceil -1\\), the left child index is \\(2i+1\\), and the right child index is \\(2i+2\\).\nThere are two kinds of heaps, max-heap and min-heap. In a max-heap, for every node other than the root, the value is not larger than that of its parent. In a min-heap, for every node other than the root, the value is not smaller than that of its parent.\n2. Maintaining the heap property The algorithm is implemented below.\nvoid max_heapify(int *a, int n, int i) { int l = 2 * i + 1, r = 2 * i + 2; int temp, temp_i = i; if (l \u0026lt; n \u0026amp;\u0026amp; a[l] \u0026gt; a[i]) temp_i = l; if (r \u0026lt; n \u0026amp;\u0026amp; a[r] \u0026gt; a[temp_i]) temp_i = r; if (temp_i != i) { temp = a[i]; a[i] = a[temp_i]; a[temp_i] = temp; max_heapify(a, n, temp_i); } return; } 3. Building a heap The algorithm is implemented below.\nvoid build_max_heap(int *a, int n) { int i = n / 2 - 1; for (; i \u0026gt;= 0; --i) max_heapify(a, n, i); return; } 4. The heapsort algorithm The algorithm is implemented below.\nvoid heap_sort(int *a, int n) { int i, temp; build_max_heap(a, n); for (i = n - 1; i \u0026gt; 0; --i) { temp = a[0]; a[0] = a[i]; a[i] = temp; max_heapify(a, i, 0); } return; } The running time of heapsort is \\(O(n\\log n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/probabilistic-analysis-and-randomized-algorithms/",
        "title": "Probabilistic Analysis and Randomized Algorithms",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2021.02.22",
        "body": "1. The hiring problem We have used worst-case analysis in the previous analysis of problems. Another approach is probabilistic analysis, in which we analyze algorithms via average-case running time.\n2. Indicator random variables The indicator random variable associated with event \\(A\\) is defined as [I(A) = \\begin{cases} 1 \u0026amp; \\text{if \\(A\\) occurs,} \\\\\n0 \u0026amp; \\text{if \\(A\\) does not occur.} \\end{cases}]\nUsing indicator random variables, we obtain the average-case hiring cost of the hiring problem is \\(O(c \\log n)\\).\n3. Randomized algorithms In order to use probabilistic analysis, we need to know the distribution of the inputs. In many cases, we know very little about it. Yet we often use probability and randomness as a tool for algorithm design and analysis. An algorithm is randomized if its behavior is determined not only by its input but also by values produced by a random-number generator.\nThe permuting arrays algorithms are implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void permute_by_sorting(int *a, int n) { int *p = malloc(sizeof(int)*n); int i, j, temp_p, temp_a; for (i = 0; i \u0026lt; n; ++i) p[i] = rand(); for (i = 1; i \u0026lt; n; ++i) { temp_p = p[i]; temp_a = a[i]; j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; p[j] \u0026gt; temp_p) { p[j+1] = p[j]; a[j+1] = a[j]; j -= 1; } p[j+1] = temp_p; a[j+1] = temp_a; } free(p); return; } void randomize_in_place(int *a, int n) { int i, j, temp; for (i = 0; i \u0026lt; n; ++i) { j = rand() % n; temp = a[i]; a[i] = a[j]; a[j] = temp; } return; } "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E6%B3%A5%E6%B3%9E/",
        "title": "泥泞",
        "section": "posts",
        "tags": ["多余的话"],
        "date" : "2021.01.01",
        "body": "一场大雪给2020年画上了终止符。大清早起来，窗外的世界已是银装素裹。雪一直都是人们赞美的对象，它洁白无暇，冰清玉洁，往往是高洁的象征。但是当白雪融化，美好的一切却又变了样。\n每当这个时候，我总会想起高中做的一篇现代文阅读，迟子建的《泥泞》。我也记不清整个高中总共做过多少篇现代文阅读，甚至记不清高考的现代文阅读是哪篇，但这篇却总在我的记忆里不曾被忘记。 迟子建说，北方的初春是肮脏的，这肮脏当然源自于我们曾经热烈赞美过的纯洁无瑕的雪。 在不那么靠北的地方，不需要等到初春，太阳出来不久，雪就已经开始融化。早起的做题家和打工人匆匆走过，雪地上的脚印一层叠着一层，洁白的雪也从白色变成灰色，又变成黑色。太阳渐渐升高，雪渐渐融化，雪水将灰尘和剩下的还未融化的雪混合在一起，变成了可乐味的碎碎冰。\n迟子建说她“热爱这种浑然天成的泥泞”，我可一点都不喜欢。我小心翼翼地走在碎碎冰里，混合着泥污的雪吸附在我的鞋边，就像在我的鞋上围了一层抹布。脚步要是稍微重一点的话，泥水便会溅到裤子上。可总不能因为怕脏，就不往前走了。要是走雪路，就放开了在雪地撒欢；要是走泥路，就慢慢地轻轻地走；要是泥水结了冰，就小步小步地往前挪。不一样地路有不一样地走法，或快或慢，有潇洒也有狼狈，总不能因为不愿弄脏裤子就停步不前，更不能因为前路结冰就被吓得尿裤子。\n前路未卜，但行无妨。走一个虎虎生风，走一个一日千里，走一个恍如隔世。\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/sed-and-awk/",
        "title": "Sed and Awk",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.09.30",
        "body": "1. Sed # read from stdin and execute command sed \u0026#39;command\u0026#39; # read from a file and execute command sed \u0026#39;command\u0026#39; filename # read from a file and execute multiple commands sed \u0026#39;command1; command2\u0026#39; filename sed \u0026#39; command1 command2\u0026#39; filename 1.1 Address and pattern You can specify lines to which the command is applied using address. The address can be a line number 2, or a range of lines 2,3.\nsed \u0026#39;2,3command\u0026#39; # OR sed -e \u0026#39;2 { commands }\u0026#39; You can also filter lines using text pattern.\nsed \u0026#39;/pattern/command\u0026#39; 1.2 Basic edition Substituting command.\nsed \u0026#39;s/string1/string2/[flag]\u0026#39; file The command only replace the first occurrence in each line. Using flag g to replace all occurrences.\nDeleting command is usually in conjunction with address or text pattern.\nsed \u0026#39;2d\u0026#39; filename sed \u0026#39;3,$d\u0026#39; filename sed \u0026#39;/number 1/d\u0026#39; filename Inserting and appending commands.\n# insert before line sed \u0026#39;[address]i\\newline\u0026#39; filename # append after line sed \u0026#39;[address]a\\newline\u0026#39; filename Changing command.\nsed \u0026#39;[address]c\\newline\u0026#39; filename Transforming command.\nsed \u0026#39;[address]y/inchars/outchars/\u0026#39; filename Printing command. Use option -n to ignore all output except printing command.\n# print the line sed -n \u0026#39;[address]p\u0026#39; filename # print the line number sed -n \u0026#39;[address]=\u0026#39; filename # print the line with nonprintable characters sed -n \u0026#39;[address]l\u0026#39; filename Writing command. Note that the sed do not change the content in files.\nsed \u0026#39;[address]w filename2\u0026#39; filename1 Read and append the content from a file.\nsed \u0026#39;[address]r filename2\u0026#39; filename1 1.3 Yank and paste The buffer area that holds the text to be processed is called pattern space. Sed utilizes another buffer area called holding space for yanking and pasting.\nCopy command.\nsed \u0026#39;[address]h\u0026#39; # append the content to holding space sed \u0026#39;[address]H\u0026#39; Paste command.\nsed \u0026#39;[address]g\u0026#39; # append the content to pattern space sed \u0026#39;[address]G\u0026#39; Exchange command.\n# exchange the content sed \u0026#39;[address]x\u0026#39; 1.4 Negating commands # not paste sed -n \u0026#39;[address]!p\u0026#39; 1.5 Multiline commands Navigate the next line.\nsed -n \u0026#39;[address]{n;p}\u0026#39; Combine the next line.\nsed -n \u0026#39;[address]{N;p}\u0026#39; Only delete/print the first line.\nsed \u0026#39;[address]{N;D}\u0026#39; sed -n \u0026#39;[address]{N;P}\u0026#39; 2. Basic awk The awk program is similar to sed, but more powerful. It reads the contents line by line and executes script.\n# read from stdin and execute command awk \u0026#39;{script}\u0026#39; # read from a file and execute {script} awk \u0026#39;{script}\u0026#39; filename # read from a file and execute multiple commands awk \u0026#39;{script1; script2}\u0026#39; filename awk \u0026#39;{ script1 script2}\u0026#39; filename Some scripts can be run before or after processing data.\nawk \u0026#39;BEGIN {script1} {script2} END {script3}\u0026#39; 2.1 Use variables One of the primary features of awk is to manipulate data in the text file. Awk assigns $0 to represent the entire line, and $n to represent the nth data field. The data field is the contents separated by a field separation character. The default field separation character is any whitespace character, such as tab or space characters.\n# print the first data field of each line awk \u0026#39;{print $1}\u0026#39; You can use a different field separation character by changing the built-in variable FS.\n# print the first data field separated by \u0026#34;,\u0026#34; of each line awk \u0026#39;BEGIN {FS=\u0026#34;,\u0026#34;} {print $1}\u0026#39;    variable description     FS input field separation character   RS input record separation character   OFS output field separation character   ORS output record separation character    2.2 Use patterns Similar to sed, you can filter lines using text pattern. But awk provides more features.\nawk \u0026#39;/pattern/{script}\u0026#39; Filter in a specific data field.\n# only filter the text pattern in the data field 1 awk \u0026#39;$1 ~ /pattern/{script}\u0026#39; 2.3 Conditional expressions Operations include ==, \u0026lt;=, \u0026lt;, \u0026gt;= and \u0026gt;.\nawk \u0026#39;$1 == \u0026#34;data\u0026#34;{script}\u0026#39; 2.4 Formatted printing Awk provides a formatted printing command printf. It performs the same way with printf in C programming.\nawk \u0026#39;{printf \u0026#34;%d \u0026#34; $1}\u0026#39; awk \u0026#39;{printf \u0026#34;%.2f \u0026#34; $2}\u0026#39; awk \u0026#39;{printf \u0026#34;%12s\u0026#34; $3}\u0026#39; 2.5 Discussion Rather than just editor commands, awk is a programming language. As far as I\u0026rsquo;m concerned, features like structured statements, functions are not necessary. If the task is so complicated that loops or functions are needed, it would better to use other general-purpose languages, such as Perl/Ruby/Python. Thus the section about awk stops here.\n3. Regular expressions Regular expressions are keys to sed and awk. A regular expression is a pattern template you define to filter text.\n3.1 Basic regular expressions The simplest regular expression is plain text. Remember that regular expression patterns are case sensitive.\n# filter lines with word \u0026#39;hello\u0026#39; sed -n \u0026#39;/hello/p\u0026#39; awk \u0026#39;/hello/{print $0}\u0026#39; These special characters are recognized by regular expressions:\n.*[]^${}\\+?|() The backslash(\\) is used to escape special characters.\nsed -n \u0026#39;/\\$/p\u0026#39; Although forwardslash is not a special character, it is used to separate the pattern and command/script in sed/awk. Thus you need to escape it before use it\nsed -n \u0026#39;/\\//p\u0026#39; Anchor characters include the caret (^) and the dollar sign ($).\n# filter lines begin with the word \u0026#39;hello\u0026#39; sed -n \u0026#39;/^hello/p\u0026#39; # filter lines end with the word \u0026#39;world\u0026#39; sed -n \u0026#39;/world$/p\u0026#39; Note: if the caret is not at the beginning, or the dollar sign is not at the end, they do not act as special characters. which means you do not need to escape them.\nThe dot (.) is used to match any single character except a newline character.\n# filter lines with \u0026#39;.at\u0026#39;, such as \u0026#39;cat\u0026#39;, \u0026#39;hat\u0026#39;, and even \u0026#39; at\u0026#39; sed -n \u0026#39;/.at/p\u0026#39; Square brackets are used to define a class of characters.\n# filter lines with only \u0026#39;cat\u0026#39; or \u0026#39;hat\u0026#39; sed -n \u0026#39;/[ch]at/p\u0026#39; # filter lines with \u0026#39;.at\u0026#39; but except \u0026#39;cat\u0026#39; nor \u0026#39;hat\u0026#39; sed -n \u0026#39;/[^ch]at/p\u0026#39; # filter lines with \u0026#39;hello\u0026#39; non-case-sensitively sed -n \u0026#39;/[Hh][Ee][Ll][Ll][Oo]/p\u0026#39; Use ranges to simplify the character class.\n# filter lines with any digit sed -n \u0026#39;/[0-9]/p\u0026#39; # filter lines with any \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39; or \u0026#39;z\u0026#39; sed -n \u0026#39;/[a-cx-z]/p\u0026#39; There are also some special character classes:\n [[:alpha:]] means [a-zA-Z] [[:alnum:]] means [a-zA-Z0-9] [[:blank:]] means [ \\t] [[:digit:]] means [0-9] [[:lower:]] means [a-z] [[:upper:]] means [A-Z] [[:print:]] means any printable character [[:punct:]] means any punctuation character [[:space:]] means any whitespace character: Space, Tab, NL, FF, VT, CR  Placing an asterisk after a character signifies that the character must appear zero or more times.\n# filter lines with \u0026#39;scho*l\u0026#39;, such as \u0026#39;schl\u0026#39;, \u0026#39;schol\u0026#39; and \u0026#39;school\u0026#39;. sed -n \u0026#39;/scho*l/p\u0026#39; # combined with dot sed -n \u0026#39;/sch.*l/p\u0026#39; # combined with character class sed -n \u0026#39;/sch[oO]*l/p\u0026#39; 3.2 Extended regular expressions Extended regular expressions provide more features. But they are not supported by sed.\nThe question mark is used after a character to signify that the character must appear zero or one time.\n# filter lines with \u0026#39;bt\u0026#39; or \u0026#39;bet\u0026#39; sed -n \u0026#39;/be?t/p\u0026#39; The plus sign is used after a character to signify that the character must appear one or more times.\n# filter lines with \u0026#39;bet\u0026#39;, \u0026#39;beet\u0026#39; or \u0026#39;beeeeet\u0026#39; sed -n \u0026#39;/be+t/p\u0026#39; Curly braces are used to specify a limit on a repeatable pattern.\n# filter lines with \u0026#39;beet\u0026#39; sed -n \u0026#39;/be{2}t/p\u0026#39; # filter lines with \u0026#39;beet\u0026#39; or \u0026#39;beeet\u0026#39; sed -n \u0026#39;/be{2,3}t/p\u0026#39; The pipe symbol (|) is used to combine two or more patterns via logical OR.\n# filter lines with \u0026#39;cat\u0026#39; or \u0026#39;dog\u0026#39; sed -n \u0026#39;/cat|dog/p\u0026#39; Parentheses are used to group a pattern in another pattern.\n# here the pattern \u0026#39;urday\u0026#39; acts as a character sed -n \u0026#39;/Sat(urday)?/p\u0026#39; "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/divide-and-conquer/",
        "title": "Divide-and-Conquer",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.08.17",
        "body": "1. The maximum-subarray problem The algorithm is implemented below.\nvoid find_maximum_subarray(int *a, int *low, int *high) { if (*low == *high) return; int mid = (*low + *high) / 2, i; // left recursion  int low1 = *low, high1 = mid; find_maximum_subarray(a, \u0026amp;low1, \u0026amp;high1); int max1 = 0; for (i = low1; i \u0026lt;= high1; ++i) max1 += a[i]; // right recursion  int low2 = mid+1, high2 = *high; find_maximum_subarray(a, \u0026amp;low2, \u0026amp;high2); int max2 = 0; for (i = low2; i \u0026lt;= high2; ++i) max2 += a[i]; // subarray across mid point  // left part  int low3, sum_left = 0, max3_left = a[mid]; for (i = mid; i \u0026gt;= *low; --i) { sum_left += a[i]; if (sum_left \u0026gt;= max3_left) {low3 = i; max3_left = sum_left;} } // right part  int high3, sum_right = 0, max3_right = a[mid+1]; for (i = mid+1; i \u0026lt;= *high; ++i) { sum_right += a[i]; if (sum_right \u0026gt;= max3_right) {high3 = i; max3_right = sum_right;} } // merge  int max3 = max3_left + max3_right; // return  if (max1 \u0026gt;= max2 \u0026amp;\u0026amp; max1 \u0026gt;= max3) {*low = low1; *high = high1;} else if (max2 \u0026gt;= max3) {*low = low2; *high = high2;} else {*low = low3; *high = high3;} return; } 2. Strassen\u0026rsquo;s algorithm for matrix multiplication The square matrix multiply algorithm is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int* square_matrix_multiply(int *a, int *b, int d) { int i, j, k; int *c = malloc(sizeof(int)*d*d); for (i = 0; i \u0026lt; d; ++i) for (j = 0; j \u0026lt; d; ++j) { int index_c = d * i + j; *(c+ index_c) = 0; for (k = 0; k \u0026lt; d; ++k) { int index_a = d * i + k, index_b = d * k + j; *(c + index_c) += *(a + index_a) * *(b + index_b); } } return c; } The simple divide-and-conquer version is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int* square_matrix_multiply_recursive( int *a, int ax1, int ay1, int ax2, int ay2, int *b, int bx1, int by1, int bx2, int by2, int d) { int n = ax2 - ax1 + 1; int *c = malloc(sizeof(int)*n*n); if (n == 1) { *c = *(a + (ax1 * d + ay1)) * *(b + (bx1 *d + by1)); } else { int m = n / 2; int a11x1 = ax1, a11y1 = ay1, a11x2 = ax1+m-1, a11y2 = ay1+m-1; int a12x1 = ax1, a12y1 = ay1+m, a12x2 = ax1+m-1, a12y2 = ay2; int a21x1 = ax1+m, a21y1 = ay1, a21x2 = ax2, a21y2 = ay1+m-1; int a22x1 = ax1+m, a22y1 = ay1+m, a22x2 = ax2, a22y2 = ay2; int b11x1 = bx1, b11y1 = by1, b11x2 = bx1+m-1, b11y2 = by1+m-1; int b12x1 = bx1, b12y1 = by1+m, b12x2 = bx1+m-1, b12y2 = by2; int b21x1 = bx1+m, b21y1 = by1, b21x2 = bx2, b21y2 = by1+m-1; int b22x1 = bx1+m, b22y1 = by1+m, b22x2 = bx2, b22y2 = by2; int *c111 = square_matrix_multiply_recursive( a, a11x1, a11y1, a11x2, a11y2, b, b11x1, b11y1, b11x2, b11y2, d); int *c112 = square_matrix_multiply_recursive( a, a12x1, a12y1, a12x2, a12y2, b, b21x1, b21y1, b21x2, b21y2, d); int *c121 = square_matrix_multiply_recursive( a, a11x1, a11y1, a11x2, a11y2, b, b12x1, b12y1, b12x2, b12y2, d); int *c122 = square_matrix_multiply_recursive( a, a12x1, a12y1, a12x2, a12y2, b, b22x1, b22y1, b22x2, b22y2, d); int *c211 = square_matrix_multiply_recursive( a, a21x1, a21y1, a21x2, a21y2, b, b11x1, b11y1, b11x2, b11y2, d); int *c212 = square_matrix_multiply_recursive( a, a22x1, a22y1, a22x2, a22y2, b, b21x1, b21y1, b21x2, b21y2, d); int *c221 = square_matrix_multiply_recursive( a, a21x1, a21y1, a21x2, a21y2, b, b12x1, b12y1, b12x2, b12y2, d); int *c222 = square_matrix_multiply_recursive( a, a22x1, a22y1, a22x2, a22y2, b, b22x1, b22y1, b22x2, b22y2, d); int i, j; for (i = 0; i \u0026lt; m; ++i) for (j = 0; j \u0026lt; m; ++j) { *(c+(i*n+j)) = *(c111+(i*m+j)) + *(c112+(i*m+j)); *(c+(i*n+j+m)) = *(c121+(i*m+j)) + *(c122+(i*m+j)); *(c+((i+m)*n+j)) = *(c211+(i*m+j)) + *(c212+(i*m+j)); *(c+((i+m)*n+j+m)) = *(c221+(i*m+j)) + *(c222+(i*m+j)); } } return c; } The Strassen\u0026rsquo;s method is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; int* square_matrix_multiply_strassens_method( int *a, int ax1, int ay1, int ax2, int ay2, int d1, int *b, int bx1, int by1, int bx2, int by2, int d2) { int n = ax2 - ax1 + 1; int *c = malloc(sizeof(int)*n*n); if (n == 1) { *c = *(a + (ax1 * d1 + ay1)) * *(b + (bx1 *d2 + by1)); } else { int m = n / 2; int a11x1 = ax1, a11y1 = ay1, a11x2 = ax1+m-1, a11y2 = ay1+m-1; int a12x1 = ax1, a12y1 = ay1+m, a12x2 = ax1+m-1, a12y2 = ay2; int a21x1 = ax1+m, a21y1 = ay1, a21x2 = ax2, a21y2 = ay1+m-1; int a22x1 = ax1+m, a22y1 = ay1+m, a22x2 = ax2, a22y2 = ay2; int b11x1 = bx1, b11y1 = by1, b11x2 = bx1+m-1, b11y2 = by1+m-1; int b12x1 = bx1, b12y1 = by1+m, b12x2 = bx1+m-1, b12y2 = by2; int b21x1 = bx1+m, b21y1 = by1, b21x2 = bx2, b21y2 = by1+m-1; int b22x1 = bx1+m, b22y1 = by1+m, b22x2 = bx2, b22y2 = by2; int *s1 = malloc(sizeof(int)*m*m); int *s2 = malloc(sizeof(int)*m*m); int *s3 = malloc(sizeof(int)*m*m); int *s4 = malloc(sizeof(int)*m*m); int *s5 = malloc(sizeof(int)*m*m); int *s6 = malloc(sizeof(int)*m*m); int *s7 = malloc(sizeof(int)*m*m); int *s8 = malloc(sizeof(int)*m*m); int *s9 = malloc(sizeof(int)*m*m); int *s10 = malloc(sizeof(int)*m*m); int i, j; for (i = 0; i \u0026lt; m; ++i) for (j = 0; j \u0026lt; m; ++j) { *(s1+(i*m+j)) = *(b+(b12x1+i)*d2+b12y1+j) - *(b+(b22x1+i)*d2+b22y1+j); *(s2+(i*m+j)) = *(a+(a11x1+i)*d1+a11y1+j) + *(a+(a12x1+i)*d1+a12y1+j); *(s3+(i*m+j)) = *(a+(a21x1+i)*d1+a21y1+j) + *(a+(a22x1+i)*d1+a22y1+j); *(s4+(i*m+j)) = *(b+(b21x1+i)*d2+b21y1+j) - *(b+(b11x1+i)*d2+b11y1+j); *(s5+(i*m+j)) = *(a+(a11x1+i)*d1+a11y1+j) + *(a+(a22x1+i)*d1+a22y1+j); *(s6+(i*m+j)) = *(b+(b11x1+i)*d2+b11y1+j) + *(b+(b22x1+i)*d2+b22y1+j); *(s7+(i*m+j)) = *(a+(a12x1+i)*d1+a12y1+j) - *(a+(a22x1+i)*d1+a22y1+j); *(s8+(i*m+j)) = *(b+(b21x1+i)*d2+b21y1+j) + *(b+(b22x1+i)*d2+b22y1+j); *(s9+(i*m+j)) = *(a+(a11x1+i)*d1+a11y1+j) - *(a+(a21x1+i)*d1+a21y1+j); *(s10+(i*m+j)) = *(b+(b11x1+i)*d2+b11y1+j) + *(b+(b12x1+i)*d2+b12y1+j); } int *p1 = square_matrix_multiply_strassens_method( a, a11x1, a11y1, a11x2, a11y2, d1, s1, 0, 0, m-1, m-1, m); int *p2 = square_matrix_multiply_strassens_method( s2, 0, 0, m-1, m-1, m, b, b22x1, b22y1, b22x2, b22y2, d2); int *p3 = square_matrix_multiply_strassens_method( s3, 0, 0, m-1, m-1, m, b, b11x1, b11y1, b11x2, b11y2, d2); int *p4 = square_matrix_multiply_strassens_method( a, a22x1, a22y1, a22x2, a22y2, d1, s4, 0, 0, m-1, m-1, m); int *p5 = square_matrix_multiply_strassens_method( s5, 0, 0, m-1, m-1, m, s6, 0, 0, m-1, m-1, m); int *p6 = square_matrix_multiply_strassens_method( s7, 0, 0, m-1, m-1, m, s8, 0, 0, m-1, m-1, m); int *p7 = square_matrix_multiply_strassens_method( s9, 0, 0, m-1, m-1, m, s10, 0, 0, m-1, m-1, m); for (i = 0; i \u0026lt; m; ++i) for (j = 0; j \u0026lt; m; ++j) { *(c+(i*n+j)) = *(p5+(i*m+j)) + *(p4+(i*m+j)) - *(p2+(i*m+j)) + *(p6+(i*m+j)); *(c+(i*n+j+m)) = *(p1+(i*m+j)) + *(p2+(i*m+j)); *(c+((i+m)*n+j)) = *(p3+(i*m+j)) + *(p4+(i*m+j)); *(c+((i+m)*n+j+m)) = *(p5+(i*m+j)) + *(p1+(i*m+j)) - *(p3+(i*m+j)) - *(p7+(i*m+j)); } } return c; } 3. The substitution method for solving recurrences The substitution method comprises two steps:\n Guess the form of the solution. Use mathematical induction to find the constants and show that the solution works.  Subtle skill: Sometimes you might correctly guess the solution of a recurrence, but some how the math fails to work out. For example, consider the recurrence,\n[T(n) = T(\\lfloor n/2 \\rfloor) + T(\\lceil n/2 \\rceil) + 1. ]\nWe guess the solution is \\(T(n) = O(n)\\). We obtain,\n[T(n) \\leq c\\lfloor n/2 \\rfloor + c\\lceil n/2 \\rfloor + 1 = cn + 1,]\nwhich does not implies \\(T(n) \\leq cn\\). If our guess is \\(T(n) \\leq cn - d\\), we have\n[T(n) \\leq cn -2d + 1.]\nwhich implies that \\(T(n) \\leq cn -d\\) as long as \\(d \\geq 1\\).\n4. The recursion-tree method for solving recurrences A recursion tree is usually used to generate a good guess. You can then verify by the substitution method. When using a recursion tree to generate a good guess, you can often tolerate a small amount of \u0026ldquo;sloppiness\u0026rdquo;.\n5. The master method for solving recurrences Let \\(a \\geq 1\\) and \\(b \u0026gt; 1\\) be constants, let \\(f(n)\\) be a function, and let \\(T(n)\\) be defined on the nonnegative integers by the recurrence [T(n) = aT(n/b) + f(n),] where we interpret \\(n/b\\) to mean either \\(\\lfloor n/b \\rfloor\\) or \\(\\lceil n/b \\rceil\\). Then \\(T(n)\\) has the following asymptotic bounds:\n If \\(f(n) = O(n^{\\log_b a - \\epsilon})\\) for some constant \\(\\epsilon \u0026gt; 0\\), then \\(T(n) = \\Theta(n^{\\log_b a})\\). If \\(f(n) = \\Theta(n^{\\log_b a})\\), then \\(T(n) = \\Theta(n^{\\log_b a}\\lg n)\\). If \\(f(n) = \\Omega(n^{\\log_b a + \\epsilon})\\) for some constant \\(\\epsilon \u0026gt; 0\\), and if \\(af(n/b) \\leq cf(n)\\) for some constant \\(c \u0026lt; 1\\) and all sufficiently large \\(n\\), then \\(T(n) = \\Theta(f(n))\\).  "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/shell-scripting/",
        "title": "Shell Scripting",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.08.06",
        "body": "1. Basic scripting building 1.1 Display messages Use echo to display messages.\necho \u0026#34;Hello world!\u0026#34; 1.2 Use variables Define and reference a variable.\nval=10 echo ${val} In most cases, the curly brackets can be ignored.\nval=str # ignore curly brackets echo $val # ignoring curly brackets will lead to error echo ${val}ing Define and reference an array.\na[0]=1 echo ${a[0]} # or a = (1 2 3) echo ${a[0]} Note: bash treats all values as string.\n1.3 Exit Use echo $? to check the exit status. Use exit N to return the status N.\n2. Conditional statements 2.1 if-then statements if command; then commands elif command; then commands else commands fi The commands under the then statement will be executed only if the command after if statement is a valid command and the exit status is zero.\n2.2 Testing conditions Besides commands, bash provides a way to test conditions. There are three types of conditions:\n numeric comparisons string comparisons file comparisons  Use double parentheses for numeric comparisons, including most operators in C and ** for exponentiation.\nif (( expression )); then commands fi Use double square brackets for string comparisons, including normal string operators and =~ for regular expression.\nif [[ comparison ]]; then commands fi The file comparisons are the most powerful and most used comparisons in shell scripting.\nif [ condition ]; then commands fi    Comparison Description     -e file Check if file exists   -d file Check if file exists and is a directory   -f file Check if file exists and is a file   -r file Check if file exists and is readable   -w file Check if file exists and is writable   -x file Check if file exists and is executable   -s file Check if file exists and is not empty   -O file Check if file exists and is owned by the current user   -G file Check if file exists and is owned by the current group   file1 -nt file2 Check if file1 is newer than file2   file1 -ot file2 Check if file1 is older than file2    In addition, you can combine conditions using AND (\u0026amp;\u0026amp;) and OR (||).\n2.3 case statements case variable in pattern1) commands ;; pattern2 | pattern3) commands ;; *) commands ;; esac 3. Looping statements 3.1 for statements for var in words; do commands done We can create words by brace expansion, wildcards or command substitution.\n# brace expansion for var in {a..z}; do commands done # wildcards for var in *.txt; do commands done # command substitution for var in $(command); do commands done We can change the value of IFS to change separator temporarily.\nIFS.OLD=$IFS IFS=$\u0026#39;\\n\u0026#39;:;\u0026#34; commands IFS=$IFS.OLD Bash also provides the C-style for statements.\nfor (( expression1; expression2; expression3 )); do commands done 3.2 while and until statements # while while command; do commands done # until until command; do commands done 3.3 Control the loop Two commands are used to control what happens inside of a loop:\n break continue  break n can indicate the level of the loop to break out of. By default n is 1.\n3.4 Process the output of a loop You can redirect or pipe the output of a loop within the script.\n# redirect for var in words; do commands done \u0026gt; output.txt # pipe for var in words; do commands done | grep txt 4. Handle input 4.1 Command line parameters  Use $0 to refer to the script name. Use $1, $2 and so on to refer to the command line parameters. If the number is larger than 9, use curly brackets ${n}. $# contains the number of parameters. Use ${!#} to refer the last parameter.  Both $* and $@ include all the command line parameters. The former takes all the parameters as a single word, while the latter takes all the parameters as separate words.\n4.2 Being shifty shift moves each parameter variable one position to the left by default. For example, after shift command, $3 refers to the fourth parameter, $2 refers to the third parameter, and $1 refers to the second parameter. Note that $0 always refers to the script name.\nYou can use shift to work with options.\nwhile [ -n \u0026#34;$1\u0026#34; ]; do case \u0026#34;$1\u0026#34; in -a) commands ;; *) echo \u0026#34;Error\u0026#34; ;; esac shift done Usually the Linux-style command looks like command options parameter, and some options even requre another parameters, such as\nls -a rm -rf file curl -o outputfile url In such cases, getopts is a better choice rather than shift.\ngetopts optstring opt The optstring lists all valid option characters. A colon after a character means the option requires a value. Each time it is invoked, an option is assigned in opt, and the index of next option is assigned in OPTIND. If the option requres a value, it will be stored in OPTARG. Thus OPTIND should be initialized as 1 at first. Here is an example.\nOPTIND=1 while getopts a:bc opt; do case \u0026#34;$opt\u0026#34; in a) # store value in val val=$OPTARG commands ;; b) commands ;; c) commands *) echo \u0026#34;Error\u0026#34; ;; esac done shift $(($OPTIND-1)) for var in \u0026#34;$@\u0026#34;; do commands done 4.3 Get user input There are two forms of read command:\n# form 1 echo -n question read var # form 2 read -p question var Use -t option to deal with timing out.\necho -n question if read -t seconds var; then commands else echo \u0026#34;Time out!\u0026#34; fi Use -n option to limit the input size.\n# accept only one character read -n1 var Use -s option to prevent the input from displaying on the monitor.\necho -n \u0026#34;Enter your password: \u0026#34; read -s passwd Read from file.\ncat file.txt | while read line; do commands done 5. File descriptors 5.1 Redirect to a file descriptor command \u0026gt;\u0026amp;2 5.2 Redirect a file descriptor to files exec 1\u0026gt;file1 exec 0\u0026lt;file2 5.3 Create your own file descriptors exec 3\u0026gt;file1 exec 4\u0026lt;file2 exec 5\u0026lt;\u0026gt;file3 Save the STDIN/STDOUT file descriptor location to another file descriptor temporarily to read/write a file.\nexec 3\u0026gt;\u0026amp;1 exec 1\u0026gt;file1 echo \u0026#34;hello world\u0026#34; # write to file1 exec 1\u0026gt;\u0026amp;3 echo \u0026#34;hello world\u0026#34; # write to STDOUT exec 3\u0026lt;\u0026amp;0 exec 0\u0026lt;file2 read var # read from file2 exec 0\u0026lt;\u0026amp;3 read var # read from STDIN Close file descriptors.\nexec 3\u0026gt;\u0026amp;- 6. Trap signals To trap signals in a script:\ntrap command signals # the trap can be modified trap command2 signals # also can be removed trap -- signals To trap a script exit\ntrap commands EXIT 7. Create functions 7.1 Basic script functions There are two forms to define a function.\n# form 1 function name { commands } #form 2 name() { commands } 7.2 Return a value The return statement is different from other programming languages. It return the exit status of the function. The exit status must be in the range of 0 to 255.\nfunction func { commands return 0 } func echo \u0026#34;The exit status is $?\u0026#34; To return a value like other programming languages, you can capture the output of the function.\nfunction func { commands echo output } output=$(func) 7.3 Use variables in functions The bash shell treats functions just like scripts. You can pass parameters to a function just like a regular script.\nfunction func { command } func parameters Parameters can also be passed to functions via global variables.\nvar=1 function func { var=2 } func # var=2 echo \u0026#34;var=$var\u0026#34; To avoid modifying the value defined outside functions, you can use local variables.\nvar=1 function func { local var=2 } func # var=1 echo \u0026#34;var=$var\u0026#34; 7.4 Array variables and functions Passing an array to a function is very confusing.\nfunction func { local newarray newarray=(;\u0026#39;echo \u0026#34;$@\u0026#34;\u0026#39;) echo ${newarray[*]} } myarray1=(1 2 3) myarray2=($(func $myarray1)) 7.5 Function recursion function func { commands var=$(func) commands } 7.6 Create a library To use functions defined in other script files:\nsource script_file.sh 7.7 Use functions on the command line Define functions in the .bashrc file, then you can use them in the command line.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/growth-of-functions/",
        "title": "Growth of Functions",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.07.20",
        "body": "1. Asymptotic notation \\(\\Theta\\)-notation: \\(f(n) \\in \\Theta(g(n))\\) if there exist positive constants \\(c_1, c_2, n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq c_1 g(n) \\leq f(n) \\leq c_2 g(n)]\n\\(O\\)-notation: \\(f(n) \\in O(g(n))\\) if there exist positive constants \\(c, n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq f(n) \\leq c g(n)]\n\\(\\Omega\\)-notation: \\(f(n) \\in \\Omega(g(n))\\) if there exist positive constants \\(c, n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq c g(n) \\leq f(n)]\n\\(o\\)-notation: \\(f(n) \\in o(g(n))\\) if for all positive constant \\(c\\), there exists \\(n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq f(n) \u0026lt; c g(n)]\n\\(\\omega\\)-notation: \\(f(n) \\in \\omega(g(n))\\) if for all positive constant \\(c\\), there exists \\(n_0\\), such that for all \\(n \\geq n_0\\),\n[0 \\leq c g(n) \u0026lt; f(n)]\n2. Standard notations and common functions 2.1 Monotonicity A function \\(f(n)\\) is monotonically increasing, if \\(m \\leq n\\) implies \\(f(m) \\leq f(n)\\).\nA function \\(f(n)\\) is monotonically decreasing, if \\(m \\leq n\\) implies \\(f(m) \\geq f(n)\\).\n2.2 Floors and ceilings [x-1 \u0026lt; \\lfloor x \\rfloor \\leq x \\leq \\lceil x \\rceil \u0026lt; x+1] [\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n] [\\left\\lceil \\frac{\\lceil x/a \\rceil}{b} \\right\\rceil = \\left\\lceil \\frac{x}{ab} \\right\\rceil] [\\left\\lfloor \\frac{\\lfloor x/a \\rfloor}{b} \\right\\rfloor = \\left\\lfloor \\frac{x}{ab} \\right\\rfloor] [\\left\\lceil \\frac{a}{b} \\right\\rceil \\leq \\frac{a+b-1}{b}] [\\left\\lfloor \\frac{a}{b} \\right\\rfloor \\geq \\frac{a-b+1}{b}]\n2.3 Modular arithmetic The value of \\(a \\mod n\\) is the residue of the quotient \\(a/n\\).\n2.4 Polynomials A polynomial in \\(n\\) of degree \\(d\\) is a function of the form\n[p(n) = \\sum_{i=0}^d a_i n^i]\n2.5 Exponentials [f(n) = a^n]\nThe Taylor series of \\(e^x\\),\n[e^x = \\sum_{i=0}^\\infty \\frac{x^i}{i!}]\n2.6 Logarithms Denote \\(\\lg n = \\log_2 n\\) and \\(\\ln n = \\log_e n\\).\n2.7 Factorials Stirling\u0026rsquo;s approximation,\n[n! = \\sqrt{2\\pi n}(\\frac{n}{e})^n(1 + \\Theta(\\frac{1}{n}))]\n2.8 Functional iteration [f^{(i)}(n) = f(f(\\dots f(n)))]\n2.9 The iteration logarithm function [\\lg^* n = \\min \\{i : \\lg^{(i)} n \\leq 1\\}]\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/learning-linux/",
        "title": "Learning Linux",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.06.11",
        "body": "1. Basic commands Navigate the filesystem \u0026amp; manipulate directories and files.\n   name description     cd change directory   ls list   cp copy   mv move   rm remove   ln create links   mkdir create directories    View the contents of files.\n   name description     file determine file type   cat view entire contents of a file   less view entire contents of a file   head view top lines of a file   tail view bottom lines of a file    Monitor system status.\n   name description     ps show processes status   top show processes status dynamically   free show memory usage   df report file system disk space usage   du estimate file space usage    Use commands.\n   name description     man show reference manuals   which show the full path of command   type show description of command type   history show command history   alias define or display aliases    2. Run commands in shell 2.1 IO redirection Redirect output.\n# overwriting the file command \u0026gt; file # appending output to the file command \u0026gt;\u0026gt; file # suppressing output. command \u0026gt; /dev/null Redirect input.\ncommand \u0026lt; inputfile # inline input redirection command \u0026lt;\u0026lt; marker data marker There is no dedicated redirection operator for redirecting errors. We have to refer to its file descriptor. The bash shell reserves the first three file descriptors as STDIN (0), STDOUT (1) and STDERR (2).\ncommand 2\u0026gt; file Redirect both output and errors.\ncommand 1\u0026gt; file1 2\u0026gt; file2 command \u0026amp;\u0026gt; file 2.2 Pipes command1 | command2 Use tee to construct a T pipe.\n# the output of command1 will be saved to file and passed to command2 command1 | tee file | command2 Some commands can be a filter in pipes.\n   name description     sort sort lines   uniq remove duplicates   tr transliterate characters   grep pattern matching by lines   sed stream editor   awk pattern scanning and processing   wc word count    2.3 Expansion Wildcards.\n   Wildcard Meaning     * match any characters   ? match any single character   [characters] match any character in brackets   [!characters] match any character not in brackets   [[:class:]] match any character in class    Class include [[:alnum:]], [[:alpha:]], [[:digit:]], [[:lower:]] and [[:upper:]].\nPathname expansion.\n# list all txt files ls *.txt # tilde for home directory cd ~ Arithmetic expansion. It only supports integer arithmetic.\n$((expression)) # the result is 2 echo $((5/2)) Brace expansion.\n# the result is \u0026#34;file1 file2 file3\u0026#34; echo file{1,2,3} # use range echo file{1..3} # nested brace expansion # the result is \u0026#34;file13 file14 file23 file 24\u0026#34; echo file{1{3,4},2{3,4}} Variable expansion.\n$var Command substitution.\n$(command) `command` Double quoting.\n# all characters are treated as ordinary characters # except dollar sign, backslash and backquote echo \u0026#34;~ will not be expanded as home directory\u0026#34; echo \u0026#34;$varstill show the value of var\u0026#34; echo \u0026#34;backslash is used to escape special characters such as \\$\u0026#34; Single quoting.\n# suppress all expansion echo \u0026#39;$(ls)\u0026#39; 2.4 Jobs Run commands one after one.\ncommand1; command2 Commands are run in foreground mode by default. Run commands in background mode.\n# run in background command \u0026amp; # show jobs launched from current terminal jobs # return the job to foreground fg %n If you exit the terminal session, all jobs, even in background mode, will be interrupted. To avoid this, run scripts without a hang-up.\nnohup command \u0026amp; The nohup command disassociates the process from the terminal, thus it redirects STDOUT and STDERR to nohup.out file. Be careful if you run multiple commands using nohup. All output is appended to nohup.out.\nUse Ctrl+C to interrupt the current-running job. Use Ctrl+Z to stop the current running job. Usually we use Ctrl+Z to move the current-running job to background.\ncommand # stop by Ctrl+Z # show the job number jobs # move to background bg %n # or return to foreground fg %n Use kill and killall to send other signals to processes.\n3. Environment variables Linux environment variables help to store system information, temporary data and configuration information.\nDefine a environment variable.\nvariable_name=variable_value echo $variable_name Define a global environment variable.\nvariable_name=variable_value export variable_name echo $variable_name Add new path.\nPATH=$PATH:/your/new/path 4. File permissions The permission of each file is in form of -rwxrwxrwx. The first character defines the type of the file.\n - for files d for directories l for links c for character devices b for block devices n for network devices  After that define the permissions of the owner, the group owning the file, and everyone else.\n   name description     chmod change file mod bits   chown change file owner and group    5. Filesystem The default filesystem of linux is ext filesystem. The ext filesystem uses an inode system to create a inode table, to store file information, including filename, file size, the owner \u0026amp; group, file permission and pointers to disk block.\nThe ext4 filesystem, the newest ext filesystem, is a journaling filesystem. It write file changes into a temporary file first. After data is successfully written to the storage device and the inode table is updated, the journal file is deleted. Other journaling filesystems include XFS and ReiserFS.\nAn alternative to journaling is copy-on-write. For modifying data, a snapshot is used. Even when data modification is completed, the old data is never overwritten. COW filesystems include ZFS and Btrfs.\n   name description     mount mount storage devices   fdisk manipulate disk partition table   mkfs build a Linux filesystem   fsck check and repair a Linux filesystem    Linux Logical Volume Manager (LVM) is used for managing logical volumes.\n6. Utilities in Linux world 6.1 Package management system Use packege management system to install software.\n   Linux distribution Package management system     Debian dpkg/apt   Redhat rpm/yum   OpenSuse zypper   Archlinux pacman   Gentoo emerge    6.2 Network    name description     ping verify the network connection   wget network download   curl transfer a URL   ssh remote login   scp secure file copy   sftp secure file transfer    6.3 Archive    name description     tar archiving utility   gzip compress files   rsync remote file and directory synchronization    6.4 Find files    name description     touch change file timestamp   find find files   xargs transfer input to args    APPENDIX Common Linux Directory Names\n   directory Usage     / root of the virtual directory   /bin binary directory, where many GNU user-level utilities are stored   /boot boot directory   /dev device directory   /etc system configuration files directory   /home home directory   /lib library directory, where system and application library files are stored   /media media directory, a common place for mount points   /mnt mount directory, another common place for mount points   /opt optional directory, often used to store third-party software packages and data files   /proc process directory, where hardware and process information is stored   /root root home directory   /run run directory, where runtime data is held during system operation   /sbin binary directory, where many GNU admin-level utilities are stored   /srv service directory, where local services store their files   /sys system directory, where system hardware information files are stored   /tmp temporary directory   /usr user binary directory, where the bulk of GNU user-level utilities and data files are stored   /var variable directory, for files that change frequently, such as log files    Linux Process Signals\n   Signal Name Description     1 HUP Hangs up   2 INT Interrupts   3 QUIT Stops running   9 KILL Unconditionally terminates   11 SEGV Produces segment violation   15 TERM Terminates if possible   17 STOP Stops unconditionally, but doesn\u0026rsquo;t terminate   18 TSTP Stops or pauses, but continues to run in background   19 CONT Resumes execution after STOP or TSTP    "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/getting-started/",
        "title": "Getting Started",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.05.18",
        "body": "1. Insertion sort Insertion sort is implemented below.\nvoid insertion_sort(int *a, int n) { int i, j, temp; for (i = 1; i \u0026lt; n; ++i) { temp = a[i]; j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; a[j] \u0026gt; temp) { a[j+1] = a[j]; j -= 1; } a[j+1] = temp; } return; } We use loop invariants to proof the correctness of our algorithm. A loop invariant includes three parts:\n It\u0026rsquo;s true prior to the first iteration. If it\u0026rsquo;s true before an iteration, it remain true before the next iteration. When the loop terminates, the invariant give us a useful property.  2. Analyzing algorithms The worst-case running time of insertion sort is \\(\\Theta(n^2)\\).\n3. Designing algorithms We use the idea of divide-and-conquer to design a sort algorithm, merge sort. It is implemented below.\n#include \u0026lt;stdlib.h\u0026gt; void merge(int *a, int b, int m, int e) { int i, j, k; int *a1 = (int *) malloc(sizeof(int)*(m-b+2)); for (i = b; i \u0026lt;= m; ++i) a1[i-b] = a[i]; a1[m-b+1] = 0x7FFFFFFF; int *a2 = (int *) malloc(sizeof(int)*(e-m+1)); for (j = m+1; j \u0026lt;= e; ++j) a2[j-m-1] = a[j]; a2[e-m] = 0x7FFFFFFF; i = 0; j = 0; for (k = b; k \u0026lt;= e; ++k) { if (a1[i] \u0026lt;= a2[j]) {a[k] = a1[i]; ++i;} else {a[k] = a2[j]; ++j;} } free(a1); free(a2); return; } void merge_sort_r(int *a, int b, int e) { if (e \u0026gt; b) { int m = (e + b) / 2; merge_sort(a, b, m); merge_sort(a, m+1, e); merge(a, b, m, e); } return; } void merge_sort(int *a, int n) { merge_sort_r(a, 0, n-1); return; } The worst-case running time of merge sort is \\(\\Theta(n\\log n)\\).\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/the-role-of-algorithms-in-computing/",
        "title": "The Role of Algorithms in Computing",
        "section": "posts",
        "tags": ["algorithms"],
        "date" : "2020.05.04",
        "body": "1. Algorithms An algorithm is any well-defined computational procedure. A data structure is a way to store and organize data in order to facilitate access and modifications.\n2. Algorithms as a technology Since computers are not infinitely fast, and memory is not free, efficient algorithms are important. A usual measure of efficiency is speed.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/learning-git/",
        "title": "Learning Git",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.04.16",
        "body": "1. Git Basics Initializing a repository.\ngit init Clone a repository.\ngit clone \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; Track new files or stage modified file.\ngit add \u0026lt;file\u0026gt; Remove and move files.\ngit rm \u0026lt;file\u0026gt; git mv \u0026lt;file\u0026gt; Commit all staged files.\ngit commit git commit --amend # commit to your last commit Check the status.\ngit status Show commit history.\ngit log git log --patch # show the difference Work with remotes.\ngit remote # show remotes git remote add \u0026lt;remote-name\u0026gt; \u0026lt;url\u0026gt; # add remote git remote rm \u0026lt;remote-name\u0026gt; # remove remote git remote rename \u0026lt;remote-name1\u0026gt; \u0026lt;remote-name2\u0026gt; # rename remote git fetch \u0026lt;remote-name\u0026gt; # fetch the remote git pull \u0026lt;remote-name\u0026gt; \u0026lt;branch\u0026gt; # pull = fetch and merge git push \u0026lt;remote-name\u0026gt; \u0026lt;branch\u0026gt; # push Work with tags.\ngit tag # show tags git tag -a \u0026lt;tag\u0026gt; \u0026lt;commit checksum\u0026gt; # create tag git tag -d \u0026lt;tag\u0026gt; # delete tag git push \u0026lt;remote-name\u0026gt; \u0026lt;tag\u0026gt; # push tag to remote git push \u0026lt;remote-name\u0026gt; --tags # push all tags to remote 2. Branch Git store all data as snapshots. The snapshot is organized in the form of tree structure. Each file is stored as a blob object as the leaf of the snapshot tree. If the file is not modified, git will only store a pointer to its previous blob object.\nWhen making a commit, a commit object is created, including author\u0026rsquo;s name, email, commit message, a pointer to the root node of the snapshot tree, and a pointer to its parent commit.\nBoth tags and branches are pointers to a commit object. Another important pointer is HEAD, which decide what files are shown in the current directory.\nCreate a new branch.\ngit branch \u0026lt;branch\u0026gt; Move the HEAD to point to a branch.\ngit checkout \u0026lt;branch\u0026gt; git checkout -b \u0026lt;branch\u0026gt; # create a branch and switch to it Merge a branch and delete it.\ngit merge \u0026lt;branch\u0026gt; git branch -d \u0026lt;branch\u0026gt; If the merged branch is fast-forward current branch, the command will only move current branch pointer forward. If not, the merging is based on the most recent common ancestor. A new snapshot is created and current branch pointer will be moved to the new snapshot.\nIf a merge conflict occur, git will stop merging and add conflict marker in the files that have conflicts. You have to modify manually and commit to finalize.\ngit commit When you clone a repository from Internet, there are two different pointers for each branch, one normal branch, and one remote-tracking branch. The remote-tracking branch show the branch information of the remote repository. When you commit, only the local branch pointer will move. Fetch will synchronize the remote-tracking branch pointer to the remote repository.\nAfter cloning a repository, git automatically create a local master branch tracking the remote-tracking master branch. If you want to track other branch,\ngit checkout --track \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; # if you want to have a different name git checkout -b \u0026lt;another-name\u0026gt; \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; To set a local branch to a remote-tracking branch,\ngit branch -u \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; Delete a remote branch.\ngit push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch\u0026gt; 3. Rebase Rebase command change the ancestor of a branch. It finds the common ancestor of two branches, gets all changes since the common ancestor, replays the changes to the base branch. The former branch will be deleted.\ngit rebase \u0026lt;base-branch\u0026gt; \u0026lt;topic-branch\u0026gt; Often, rebase is used when you want to contribute a project. Rebase your local branch to origin/master, and submit the pull request. It will be convenient for the maintainer to merge your changes.\nNote:\n Do not rebase commits that exist outside your repository Do not rebase commits that others may have based work on  Compared with merge, rebase will delete some history of your project, but make your project history clear.\n4. Reset and Checkout Git maintains three trees.\n HEAD: last commit snapshot, which the HEAD pointer pointing to Index: files staged and to be commit Working Directory  Reset command do three things:\n move what HEAD points to (stop here if --soft) update the Index with the contents of what HEAD points to (stop here if --mixed or no options) update the Working Directory (stop here if --hard)  Thus git reset HEAD \u0026lt;file\u0026gt; is used to unstage a staged file.\nThe main differences between reset and checkout are:\n Checkout is working-directory safe. Checkout only move the HEAD pointer, while reset move what HEAD points to.  Both reset and checkout can be followed by \u0026lt;paths\u0026gt;. Only the paths, rather than the whole directory, will be act upon.\n5. Debug Find which commit was the first one to introduce a bug or problem.\ngit bisect start git bisect bad git bisect good \u0026lt;good_commit\u0026gt; Annotate the lines with which commit was the last one to introduce a change and who authored that commit.\ngit blame -L \u0026lt;line1\u0026gt;,\u0026lt;line2\u0026gt; \u0026lt;file\u0026gt; Find any string in files, no matter current or older versions.\ngit grep \u0026lt;str\u0026gt; "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/%E6%96%87%E5%AD%A6%E6%98%AF%E4%BB%80%E4%B9%88/",
        "title": "文学是什么",
        "section": "posts",
        "tags": ["读书笔记"],
        "date" : "2018.04.17",
        "body": "1. 是一面镜子还是一束灯光 文学是什么，人们喜欢用比喻来表述。 不同的比喻代表着不同的文学观，代表着不同的美学观。\n镜与灯，是对文学最为流行的比喻。 镜子的比喻把文学理解成写实的、再现的， 而烛光的比喻则把文学看成是创造的、表现的。 在古老的镜子比喻的背后，是古老的模仿理论。 模仿论认为，文学创作是对世界的模仿，并不是创造。 模仿说在后来的发展中，受新写实主义的影响，演化成再现说。 新写实主义认为，“模仿”这个词语，意味着摹本并不是被模仿的事实事物； 它也可能意味着摹本的价值比较低。 灯的比喻背后是表现说。 表现说认为文学艺术是对人类主观世界的表现。\n文学究竟是表现还是再现，实际上这两种说法都是有问题的。\n 文学的再现不是纯粹的再现，绝对的再现是根本不可能的 表现说也存在问题，而且问题更复杂。 对“表现”本身的理解主要有两种，一是对感情的表现，一是对想象世界的表现。  在西方，在卢梭和歌德的时代之前，艺术的模仿理论始终被奉为不可更易的信条。 卢梭认为，艺术并不是对经验世界的描绘和复写，而是情感和感情的流溢。 可是把情感当成文学唯一的本质因素，这与再现说并无不同， 文学仍是再现，只不过不是对物理事实、社会事实的再现， 而是对心理事实的再现。 文学中描写的情感与现实中的情感相比在性质上已经发生了变化， 这种变化的核心就是形式化，而形式化的关键是抓住情感的本质， 使文学中的情感超越了日常情感，达于审美情感。 这种形式化不限于感情，文学对现实的再现也一定是形式化的 文学同样不是想象。想象只是形式化的手段。    形式化使得文学一定程度上与纯粹的主观世界相分离， 也一定程度上与纯粹的客观世界相分离。 文学中实际有两个世界：一方面，文学是有限的、再现的、经验的世界， 它既可以是物理事实、社会事实，也可以是人的情感世界； 另一方面，文学是无限的、象征的、超验的，文学总要借有限而达于无限。\n注：这里关于形式化的描述，我读得似懂非懂， 感觉是说的是艾布拉姆斯的《镜与灯》中描述的作品、宇宙、作家、读者之间的关系。 作品能够再现世界（即宇宙）事实，表现作家的情感和想象， 但从作品和读者之间的关系来看，作品中的事、情早已不是原来的事、情， 而是形式化的事、情，能够与读者与自己的经历和感情相联系， 所谓“一千个人眼中有一千个哈姆雷特”，即“文学总要借有限而达于无限”。\n2. 文学是语言艺术吗 语言是文学的物质媒介。语言给文学带来的东西是其他任何艺术都无法比拟的。\n 语言丰富的词汇、明晰的含义、严密的语法， 使文学更易于描写和表现广阔的社会现实生活和丰富的内心感情世界。 语言给文学带来了艺术形象的非直观性，文学比其他直观的艺术更加耐人寻味。 “语言是思想的直接现实”（马克思），是的文学作品与思想关系紧密。 语言媒介给文学最为重要的东西是语言本身的审美因素，  语言的审美因素首先体现在语音方面，语音的审美因素主要体现在节奏和格律上， 这些审美效果在诗歌中体现的最为充分； 语言的审美因素还体现在修辞中。    学习语言，研究语言，锤炼语言，永远是作家的功课。\n文学超越了语言，这种超越是在美学层面上完成的。 使文学的物质媒介完全消失，创作出绝对自由的艺术的幻想世界， 这是伟大艺术的标准。\n审美经验用语言使难以表达的。 作家往往使用形象的语言、象征的方式来解决这一问题。 文学语言的形象化，以及象征方式的运用，并不是最终的目的，而是通向目的的途径， 最终形象化的语言和象征的方式被消解，展示给读者的是作家审美经验所编织的世界。\n我们说语言是文学的物质媒介，文学具有超语言性，但并不是所有作家都是如此。 有的作家只在语言层面，充分利用语言本身的审美元素，创作华美的作品，如花间派； 超越语言进入更高的艺术境界，需要作家伟大的精神要素的保障，如陶渊明； 当然，也有在这二者寻求统一的，如杜甫。 所以如果把花间派的作品翻译成其他语言，恐怕会遇到麻烦， 因为这是一种特殊的、语言的艺术，不能转移； 但是陶渊明的作品译成另一种语言则问题不大，因为这是一种一般的、非语言的艺术， 可以转移到另一种语言而不受损失。\n注：在讨论文学的超语言性时，作者提到了索绪尔的“语言”和“言语”的区分。\n语言是一套约定俗成的、社会共同遵守的规则体系，具有一定的稳定性。 言语是语言的具体使用，主要由个人完成，体现了个性特征和个人色彩， 不同时代的语言使用也是不同的，提现了语言的发展和变化。\n语言和言语的关系上看，总是言语在先，语言在后。 言语一方面要遵守语言的规则，另一方面，也时常突破既有的语言规则， 当这种规则在言语活动中被反复演练，以至被社会接受， 这种新的表达形式就被确立为一种新的语言规则。\n3. 是美的还是真的 在文学理论中，文学与真的关系，与美的关系，是非常重要的问题。\n在古希腊，柏拉图明确声称在自己所设想的理想国中驱逐诗人。\n 柏拉图认为，所有诗人都是模仿者，模仿和真理隔着三层。 柏拉图以著名的“三种床”的例子说明他的观点：世界上有三种床， 概念上的床，实际的床，以及诗人写的床，实际的床是对概念上的床的模仿， 诗人写的床是对实际的床的模仿，是模仿的模仿，影子的影子。 文学表现的是人的感性部分。 从这方面来说，柏拉图和诗人的纷争，实际上是感性与理性的纷争。  亚里士多德批判地继承了柏拉图的学问，以朴素唯物观为方法论，构建了全新的诗学体系。 他的《诗学》是欧洲美学史上第一篇最重要的美学论文， 也是迄至前世纪末（19世纪）一切美学概念的根据。\n 亚里士多德认为，世界本身就是真实的，因此模仿世界的文学也是真实的， 而且文学更能揭示现象后面的普遍规律和本质。 文学的真实不以是否客观存在为标准，而是以客观的本质规律为标准。 关于文学与美的关系，亚里士多德认为， 具体的感性事物、现实世界不仅包含事物的本质和规律，而且也是美的具体形式， 美不可能存在在神秘的理念世界。 事物的美是由事物的整体性和和谐性决定的，文学作品是一个整体， 这体现在作品的结构、情节以至风格各个方面。  美学之父鲍姆嘉通认为人的意识可以分为感性认识和理性认识， 其中理性认识是高级认识，感性认识是低级认识。 美学的使命就是研究人的低级认识。文学是感性领域的代表， 文学就是对现实的一种感性认识。\n康德认为，世界分为两部分：物自体和现象界。 物自体超越人的认识活动，现象界才是我们周围的世界， 是人的认识能力反映出来的物象。 康德认为人们只能认识现象界，物自体是不可知的。 康德把美学当作是纯粹的主观精神活动。\n黑格尔\n 黑格尔把文学艺术与真理的关系推向了极点，认为文学同哲学一样揭示真理， 只是形式不同。 黑格尔的哲学体系中，世界的本源是理念，现实世界是理念自身发展的产物。 艺术、宗教、哲学是理念自身显现的三个阶段，而且是递进的： 艺术以感性直观的形式表现理念，宗教以表象形式，哲学以概念形式。 所以，艺术就是“真”。 在黑格尔的体系中，美首先是理念，所以美即是真。 但理念需要确定的形式显现，当理念以感性的形式显现自身的时候， 理念就不仅是真，而且是美。 所以黑格尔定义美是理念的感性显现。  虽然黑格尔赋予艺术崇高的地位，但是无论内容还是形式，艺术都无法与哲学相比， 所以黑格尔认为艺术终将解体。\n黑格尔的艺术解体论并不可取，但是他尖锐地指出了近代西方社会与文学艺术的矛盾。 黑格尔指出，“现时代”是一个“偏重理智”的时代， 并将此归结为“不利于艺术”发展的主要原因。 近代以来，自然科学获得了长足发展，取得了节节胜利。 人文科学也用自然科学的方法和手段展开研究，这对人文科学的发展必然带来益处， 但同时人文科学要承担自身品格和价值丧失的风险。\n19世纪中叶，自然科学占据了所有可认识的事物，以至于哲学变得没有了对象。 与其说自然科学瓜分了哲学的对象，不如说哲学迷失了自己的对象， 哲学总是去和科学争夺领地，其结果不是平分秋色，而只能是误入歧途。 海德格尔认为，这种误入歧途，就是传统的形而上学。 海德格尔首先从真理的概念入手，传统的真理指的是是认识与事物的符合。 人们的认识总是在探索事物背后的本质和规律，这是科学的目标。 实际上，自柏拉图和亚里士多德以来，哲学也以此为目标，所以哲学和科学是不分的。 如果哲学继续以此为目标，那么哲学终将被科学取代。\n海德格尔认为，在客观事物——他称之为“存在者”——的后面，还深藏着一个“存在”。 传统哲学关注的是“存在者”，是对存在者进行科学分析的结果， 真正的真理不是认识与事物相符，而是“存在之澄明”，也可以说是“存在者之解蔽”。 这才是哲学研究的对象。 存在之真理不能在科学中求证，却能在艺术中现身。 以往人们称之为美的东西，实际上是存在之真理的自行绽出。\n诗更是“存在的词语性创建”。 海德格尔为哲学重新划界，也对文学委以重任。 哲学以“运思”的方式，文学以“命名”的方式，共同把握存在之真理。 海德格尔重建了文学与“真”与“美”的关联。\n对于海德格尔苦苦思索的问题，中国的先哲似乎早已提及。 追求与天地精神往来，与宇宙生息公动，用有限的笔墨达于无限的形上境界， 一直是中国文学的优秀传统。 在言语道段处、思维路绝时，文学承担起把握形上真理的重任， 从而接通心灵与世界间的道路。\n注：海德格尔的东西看不懂，所以只能顺着作者的思路随便记记。\n4. 是闲暇的游戏，还是布道的牧师 文学的功用和作用，是一个相当复杂的问题。\n毫无疑问，文学具有一定的娱乐功能。\n 随者生产力的提高，人类有了剩余劳动时间。 人类最初支配劳动时间的活动，叫做消遣。 对消遣来说，剩余劳动时间是前提。 与此相对，娱乐可以在剩余劳动时间进行，也可以在剩余劳动时间之外进行， 娱乐产生的快乐就成了享乐。 所以，娱乐本身潜藏着某种危险性。 在西方，柏拉图最先看到这一点，柯林伍德认为，娱乐对人的情感有一种释放作用， 但另一方面，娱乐的需求会膨胀，这样的娱乐与娱乐艺术在社会过度发展， 构成了西方文明的危机。 维勒克和沃伦为通俗文学作了辩护，他们认为文学是“甜美（dulce）”和“有用”的统一： “有用”相当于不浪费时间，即艺术不是一种消磨时间的方式；“ 甜美”相当于不使人讨厌，不是一种义务，艺术本身就是给人的报酬。  把文学当作一种消遣方式，并不是不得了的事。 但把文学用于娱乐和文学本质的功用并不是一回事。 换言之，娱乐功能绝不是文学的本质功能。\n文学具有教育功能。\n 一方面，文学可以启人心智，文学以生动的意象为读者展现了一个真、善、美的世界， 可以开发培养人的想象能力、感受能力、思维能力和创造能力， 以及向善向美的健康心理。 另一方面，文学被纳入社会的教育体系，强化文学自身的教育功能。 文学也被用于商业广告，社会政治宣传，国际文化交流。 这些是文学的“他为”的功能。 相比于其他艺术，文学还多一个功能，文学是民族语言教育的主要途径。  娱乐和教育并不是文学所独有的功能，而且这两种功能距离文学的本质属性还有一段距离， 文学更高的功能在人类的精神领域。 古人说：“动天地，感鬼神，莫近于诗。” 说到底，动的不是天地，感的不是鬼神，感动的是人类自己。 这种感动，实际上是人类力图超越现象世界，与无限世界沟通的最初努力。 诚如今道友信所说，文学艺术“不是脱离历史现实的，而是通过具体走向永恒的作品。 艺术作品应该是通过有限，达到无限的精神桥梁，是超越世界的，从历史到普遍， 从物质到理念垂直的柱子。”\n5. 作品=内容+形式吗 文学作品是由什么构成的呢？ 把文学作品看作是由内容和形式构造而成的观点，是一个最普遍的观点。 但是，将文学技术化地分为两部分，使人难以把握文学本身。\n克莱夫·贝尔认为，艺术是有意味的形式。 这个观点是建立在视觉 艺术的基础上的，虽然艺术是相通的，但文学有其特殊性， 贝尔的理论在文学上并不适用。\n米盖尔·杜夫海纳认为，一般艺术作品中都要处理三个要素：材料、主题和表现。 在文学中，词语即使材料。 文学作品的主题离不开材料，当主题和材料达到高度的统一时， 作品的第三个因素“表现”就出现了。\n上个世纪中叶，结构主义开始被更多的人注意。 结构主义的主要目标是，突破以往从部分到整体的思维模式， 建立从整体到部分的研究思路。 在结构主义整体论中，内容形式的二分法遭到了排斥， 文学作品的存在方式得到了重新思考。 这种思考首先来自结构语言学领域。 结构语言学有两个学派，布拉格的功能学派和哥本哈根的语符学派。 前者对文学理论产生了巨大的影响。 布拉格功能学派划分了不同的语言功能，这使人们对文学语言的特殊性有了深入的认识。 沿着结构主义的整体性理念，有人顺理成章地重新思考文学作品的存在方式和构成要素， 进而主张文学作品是一个完整的结构，无需再进行内容和形式的划分， 这个完整的结构有其自己的功能，这个功能的主题就是感情表达。 但是，当结构主义的“转换性”观念和“形式化”意图被用于文学作品的研究时， 局限性被暴露出来了。 那些带着结构主义色彩的术语和规则，无不显示出与文学的疏异倾向。\n综上，这些对文学作品的种种观点，都从不同角度拓宽了人们对文学作品的认识。 但是，任何一种形式的解释和说明，都必须进行概念界定， 可是任何一种界定都会带来对文学整体的分割，任何一种界定都会导致与文学的疏异。\n其实，中国传统文论对文学的运思方法是耐人寻味的。 中国传统文学评论，主要有以下三个特点：\n 除了泛言文学的道德性和文学的社会功能外，主要以美学的考虑为中心。 属于“点、悟”式的批评，不破坏诗的“机心”，主要去激起读者意识中诗的活动， 使诗的意境重现，是一种近乎诗的结构。 即使就利用了分析、解说的批评来看，它们仍然是只提供与诗“本身”的艺术， 与其“内在机枢”有所了悟的文字，是属于美学的批评。  中国传统文论的方法论对今天的研究应该有启发意义。\n6. 作家创造了什么 形象这个词，并不是文学领域专用的。 在文学艺术中，我们也常说这个概念。 有一种观点认为，文学形象是文学作品中一切生动可感的事物或生活画面。 这个观点强调了形象的视觉性。 也有一种观点认为，文学形象就是文学作品中一切可以诉诸人的感官的感性形式。 这样，无疑可以把视觉以外的内容包容在内。\n文学形象不是纯客观的，而是主观与客观的统一。 中国古人把在想象、情感和理解等心理因素共同作用下所产生的象称为意象。 与形象相比，这个概念更准确些。 意象所提示出的世界里，包含了什么呢？ 如果每个人都能讲述的事，都能说清的道理，就不用文学来讲述说明了。 作家所要讲述的是语言难以讲清楚的事与理，这样的事与理， 就在意象所提示的复杂的经验世界中。\n意象是作家用来表达“意”的，即审美经验，“象”是工具，“象”又要由“言”来构造， 语言又是一层工具。 意象是具体的、可感的，超象也是具体的、可感的。 意象的具体是个别的具体，超象的具体就是由个别上升到一般的具体。 意象的可感是形貌上的可感，超象的可感就是形貌以上的精神内容的可感。\n风格是作家所创造出来的富有个性特征或独创性的美的形态， 它存在于内容和形式所构成的艺术整体之中。 流派与风格是联系在一起的，流派的划分主要是以艺术风格为依据的。\n7. 文学之树是长成的 各民族最早的文学形式都是诗歌。 因此，文学起源问题，实际上就是诗歌的起源问题。 关于这个问题，有两种具有代表性的观点，工具论和表现论：\n 语言的押韵和句式的整齐，都是为了方便人类记忆。 而在古代这些为了记忆而做成的韵文中，由两种形式与诗的最终产生关系更为密切， 一种是记忆部族历史的史诗，一种是祭祀仪式的祝词。 表现论则认为，文学艺术就是表现情感，表现是它唯一的目的。 举一个格罗塞《艺术的起源》中的例子，小孩子看到一只美丽的蝴蝶， 就会由衷地喊出“啊，美丽的蝴蝶！”来表示他的喜悦， 这个呼声是为了表现感情，而不是传达。 如果这句话还不够，小孩子就会叠章复唱，这个呼声就变成歌谣了。  工具论和表现论相持不下，都能找到说服人的理由。 文学是逐步产生的，也许二者都起了作用。\n诗歌：\n 诗歌最明显的语言形式就是音韵。 最早的诗和音乐是统一的。 音乐的特征，一定程度上决定了诗的特征，如叠章复唱、押韵等。 在现代诗中，音乐性已经内化于诗的内在本质中。 诗歌的语言方面与音乐分离后，获得了更专门的发展，这就是语言的隐喻和象征。  小说：\n 从小说的发展来看，小说是建立在志人叙事基础上的， 志人叙事有两个走向，一个是纪实，一个是虚构。 后来当小说样式成熟起来时，就是所谓的现实主义的和浪漫主义的。 人们在分析小说构造的组成要素时，区分出情节、人物和环境三种要素。 结构是小说家的主要美学手段。结构和情节是不同的， 结构是作家对作品的整体安排和构造，它包含对情节的安排。 但情节是作家安排的重点：作家要安排事件发展的顺序， 也要安排构成整体故事的不同情节线索的安排。 情节的发展是由人物和人与人之间的关系来推动的。 塑造生动的人物，不仅是作家表现自己感情观念的手段， 也是使作品世界成为可以理解的世界的主要方面。 在早期叙事作品中，人物性格塑造较为简单； 在现代小说中，作品更注意描写人物性格的不同方面。 有的理论家把这两种人物性格分别称为“扁平的”和“圆整的”。 扁平性格常常造成人物的类型化和观念化，遮盖了人的复杂性， 使作品的美学价值降低，并会导致读者对作品失去兴趣。 情节是在时间中展开的，也是在空间中展开的； 人物性格实在时间中形成的，更是在空间中形成的。 在情节和人物的背后是背景和环境。 作品中的环境，除了最基本的作为人物事件的背景功能外， 也常常与作家所要传达的情感观念之间有一定关联，这就是环境的隐喻作用。 情节、人物、环境，构成作品世界的要素已经齐备，作者需要一个叙事角度， 一般有两种：第三人称叙事（又称“全知叙事”）和第一人称叙事（又称“限知叙事”）。 小说提升为一种文学样式，那么小说和其他艺术一样，以有限写无限，这就是象征。 小说的象征有两种：一是在作品中设置意象，如《红楼梦》中的“玉”和“石”； 一是用整个故事来象征，如海明威的《老人与海》。  散文：\n 在所有文学样式中，散文是最复杂的一种。 最初，散文是指与韵文相对的文体。 在中国，由于骈文的出现，散文又指与骈文相对的文体。 现在的散文概念来自于朱自清的文章《什么是“散文”》，它包含了许多边缘性的品种， 如那些具有强烈文学性的书信、序、跋、记、祭文、盟文、檄文等， 和很多较为纯粹的品种，如报告文学和传记文学。 按照现在较为通行的看法，散文分为小品文、传记文学和报告文学。 小品文也是一个包含诸多更小种类文学的概念， 如上文提到的书信、游记、杂文、祭文、序跋等。 在小品文中，游记是文学性最强的，有人把游记从小品文中分离出来， 与小品文并列。 从文学史业已取得的散文成就来看，散文有以下特点：  题材广泛多样，无所不包。 不拘泥于叙事和抒情：可以叙事，但没有小说那样的负担，要把故事讲完整； 可以抒情，又不必像诗歌那样被限定在诗行的形式中。 结构自由灵活 讲求语言美    戏剧文学：\n 戏剧是一门综合艺术，包含文学要素、音乐要素、舞蹈要素、美术要素， 甚至还有建筑要素。 其中的文学要素就是剧本，剧本就是所谓的戏剧文学。 舞台的时间和空间的有限性，决定了剧本必须把叙事的要素高度集中： 剧本只能写有限的人物； 剧本必须考虑把事件尽量放在相对集中的环境中展开； 剧本必须选取最有代表性的事件，并进行压缩。 这些集中最终浓缩出戏剧的法宝——冲突。 和电影不同的是，观众很难看清楚演员的细节，所以语言是戏剧文学的主要表达手段。  戏剧中很少，甚至没有叙述人语言。 台词必须个性化，每个人讲的台词，要符合他的性别、年龄， 要反应他的身份、地位、心理和思想性格。 戏剧的人物语言要有潜台词。 台词不仅要让人听得懂，还要有表现力和感染力。   一般来说，戏剧分为悲剧、喜剧和正剧。 悲剧以不可调和的矛盾为核心展开剧情， 以代表正面力量的悲剧主人公的失败或死亡而告终。 戏剧也是展示正义与丑恶的对抗，不过在喜剧中，丑恶无法与正义抗衡， 展示了丑的滑稽可笑。 正剧可以让悲喜两种情感相互转化，和现实生活更为贴近， 也更符合现代人的情感接受方式。  影视文学：\n 电影同样是一门综合艺术，电影文学就是电影文本。 电影的基本语言是画面，电影的基本构成要素是声音、画面和运动。 电影的结构由镜头完成。 电影镜头的剪辑和组接，叫蒙太奇。 电影剧本要符合电影艺术的要求：  电影的基本语言是画面，所以电影剧本要提更具体生动的视觉形象。 电影中人物的主要表现手段是动作，动作性是衡量一部电影艺术水平的重要尺度， 如果电影中语言过多，是艺术上无能的表现。 电影剧本的结构常用闪回的手段，即在情节中嵌入非常短暂的画面片段。 $ 电视剧和电影有很多相似之处，所以有的人称之为“姊妹艺术”。 但二者是不同的：电视屏幕的视觉效果无法与电影相比， 所以在电视剧中语言又被提升起来，称为人物的主要表现手段； 电视剧常常选择贴近人们生活的题材； 在剧情结构上，电视剧体现出松散的情节结构倾向。    8. 读者的创造与被创造 在由世界、作者、作品和读者构成的动态关系中，读者既是主题也是对象。 作品只有进入到与读者发生关系的接受过程，作品才能显示出它的价值。 没有作家，就没有作品；没有读者，就没有作品价值的实现。\n对于作家来说，读者是他的对象。 读者在作品接受中，作为对象，是被作品创造着。 杜夫海纳认为，作品对读者的创造首先是鉴赏力和情趣。\n在文学鉴赏中，读者又是主体。\n 读者首先面对的是作品，文学作品的形象不是直观的， 读者需要对语言文字进行解读。 文字的解读和鉴赏是同步进行的。 读者把作家创造的世界当作美的对象世界进行鉴赏，第一步就是再现。 读者再现作品世界的手段是想象。 作品世界被呈现出来，读者就不会停留在想象水平上，理解必然会介入。 在读者的理解活动中，自然少不了情感要素。 我们把鉴赏活动分割为想象、理解和情感，只是为了说明的需要， 实际上三者是很难分开的。 鉴赏中，读者对作品所谓的填充并不是创造， 读者的创造性包含在读者的审美经验中，与其说读者创造了什么， 不如说读者在鉴赏所培养起来的审美经验中包含着潜在的创造力， 这种创造力是通向未来的，通向意识的。  文学评价：\n 文学评价和文学鉴赏是不同的，文学鉴赏是一种审美活动，以作者的美感体验为核心， 与读者的审美趣味相关； 文学评价是对作品的理性分析和认识，是从一定的标准出发的， 不能以个人的趣味作为参考系。 但是二者又紧密相连，文学评家的恰当与否，和对作品的准确理解分不开， 批评家只有对作品有充分的审美感悟，才能把握作品的全部，做出公允的评价； 另一方面，批评家对作品的评价，对读者也有一定的帮助。 文学评价的标准具有历史性，与相应历史时期的政治、经济、文化相关联， 特别是与相应历史时期的哲学美学思想关系密切。 文学创作是文学评价的基础，文学评价对文学创作有促进作用。 文学理论的概括，是建立在文学评价基础上的，是对文学评价的进一步抽象； 文学理论一旦形成，又对文学评价产生影响，对文学评价起到一定的指导作用。 文学评价的判断更近于一种价值判断，而不是知识判断。  9. 面临挑战的21世纪文学 社会分工使文学和金钱之间建立了最初的联系。 到了资本主义时期，文学作品开始成为一种商品，进入市场流通领域， 成为资本获利的手段。 一个艺术家，为了生存而出卖自己的作品，这不属于艺术商品化； 相反，如果这个艺术家被雇佣而创作，那么这就是艺术商品化。\n 创作的商品化，必定会影响作品的质量，迎合读者的低级趣味， 甚至刻意培植读者的低级趣味。 作品的商品化导致复制艺术的产生，这是对传统艺术概念的冲击。  在文学内部，文学样式的发展是不平衡的：诗歌最先产生，也最先繁荣； 诗歌衰落之后，小说是最发达的。 但总的来说，文学是衰退的，广播、电视、网络大大冲击了文学地位。\n只顾自己的感受，不顾读者和公众，是现代文学艺术骨子里的东西。 （注：似乎也是现代其他艺术的弊病。）\n"
    }
]
