[
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/sed-and-awk/",
        "title": "Sed and Awk",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.09.30",
        "body": "1. Sed # read from stdin and execute command sed \u0026#39;command\u0026#39; # read from a file and execute command sed \u0026#39;command\u0026#39; filename # read from a file and execute multiple commands sed \u0026#39;command1; command2\u0026#39; filename sed \u0026#39; command1 command2\u0026#39; filename 1.1 Address and pattern You can specify lines to which the command is applied using address. The address can be a line number 2, or a range of lines 2,3.\nsed \u0026#39;2,3command\u0026#39; # OR sed -e \u0026#39;2 { commands }\u0026#39; You can also filter lines using text pattern.\nsed \u0026#39;/pattern/command\u0026#39; 1.2 Basic edition Substituting command.\nsed \u0026#39;s/string1/string2/[flag]\u0026#39; file The command only replace the first occurrence in each line. Using flag g to replace all occurrences.\nDeleting command is usually in conjunction with address or text pattern.\nsed \u0026#39;2d\u0026#39; filename sed \u0026#39;3,$d\u0026#39; filename sed \u0026#39;/number 1/d\u0026#39; filename Inserting and appending commands.\n# insert before line sed \u0026#39;[address]i\\newline\u0026#39; filename # append after line sed \u0026#39;[address]a\\newline\u0026#39; filename Changing command.\nsed \u0026#39;[address]c\\newline\u0026#39; filename Transforming command.\nsed \u0026#39;[address]y/inchars/outchars/\u0026#39; filename Printing command. Use option -n to ignore all output except printing command.\n# print the line sed -n \u0026#39;[address]p\u0026#39; filename # print the line number sed -n \u0026#39;[address]=\u0026#39; filename # print the line with nonprintable characters sed -n \u0026#39;[address]l\u0026#39; filename Writing command. Note that the sed do not change the content in files.\nsed \u0026#39;[address]w filename2\u0026#39; filename1 Read and append the content from a file.\nsed \u0026#39;[address]r filename2\u0026#39; filename1 1.3 Yank and paste The buffer area that holds the text to be processed is called pattern space. Sed utilizes another buffer area called holding space for yanking and pasting.\nCopy command.\nsed \u0026#39;[address]h\u0026#39; # append the content to holding space sed \u0026#39;[address]H\u0026#39; Paste command.\nsed \u0026#39;[address]g\u0026#39; # append the content to pattern space sed \u0026#39;[address]G\u0026#39; Exchange command.\n# exchange the content sed \u0026#39;[address]x\u0026#39; 1.4 Negating commands # not paste sed -n \u0026#39;[address]!p\u0026#39; 1.5 Multiline commands Navigate the next line.\nsed -n \u0026#39;[address]{n;p}\u0026#39; Combine the next line.\nsed -n \u0026#39;[address]{N;p}\u0026#39; Only delete/print the first line.\nsed \u0026#39;[address]{N;D}\u0026#39; sed -n \u0026#39;[address]{N;P}\u0026#39; 2. Basic awk The awk program is similar to sed, but more powerful. It reads the contents line by line and executes script.\n# read from stdin and execute command awk \u0026#39;{script}\u0026#39; # read from a file and execute {script} awk \u0026#39;{script}\u0026#39; filename # read from a file and execute multiple commands awk \u0026#39;{script1; script2}\u0026#39; filename awk \u0026#39;{ script1 script2}\u0026#39; filename Some scripts can be run before or after processing data.\nawk \u0026#39;BEGIN {script1} {script2} END {script3}\u0026#39; 2.1 Use variables One of the primary features of awk is to manipulate data in the text file. Awk assigns $0 to represent the entire line, and $n to represent the nth data field. The data field is the contents separated by a field separation character. The default field separation character is any whitespace character, such as tab or space characters.\n# print the first data field of each line awk \u0026#39;{print $1}\u0026#39; You can use a different field separation character by changing the built-in variable FS.\n# print the first data field separated by \u0026#34;,\u0026#34; of each line awk \u0026#39;BEGIN {FS=\u0026#34;,\u0026#34;} {print $1}\u0026#39;    variable description     FS input field separation character   RS input record separation character   OFS output field separation character   ORS output record separation character    2.2 Use patterns Similar to sed, you can filter lines using text pattern. But awk provides more features.\nawk \u0026#39;/pattern/{script}\u0026#39; Filter in a specific data field.\n# only filter the text pattern in the data field 1 awk \u0026#39;$1 ~ /pattern/{script}\u0026#39; 2.3 Conditional expressions Operations include ==, \u0026lt;=, \u0026lt;, \u0026gt;= and \u0026gt;.\nawk \u0026#39;$1 == \u0026#34;data\u0026#34;{script}\u0026#39; 2.4 Formatted printing Awk provides a formatted printing command printf. It performs the same way with printf in C programming.\nawk \u0026#39;{printf \u0026#34;%d \u0026#34; $1}\u0026#39; awk \u0026#39;{printf \u0026#34;%.2f \u0026#34; $2}\u0026#39; awk \u0026#39;{printf \u0026#34;%12s\u0026#34; $3}\u0026#39; 2.5 Discussion Rather than just editor commands, awk is a programming language. As far as I\u0026rsquo;m concerned, features like structured statements, functions are not necessary. If the task is so complicated that loops or functions are needed, it would better to use other general-purpose languages, such as Perl/Ruby/Python. Thus the section about awk stops here.\n3. Regular expressions Regular expressions are keys to sed and awk. A regular expression is a pattern template you define to filter text.\n3.1 Basic regular expressions The simplest regular expression is plain text. Remember that regular expression patterns are case sensitive.\n# filter lines with word \u0026#39;hello\u0026#39; sed -n \u0026#39;/hello/p\u0026#39; awk \u0026#39;/hello/{print $0}\u0026#39; These special characters are recognized by regular expressions:\n.*[]^${}\\+?|() The backslash(\\) is used to escape special characters.\nsed -n \u0026#39;/\\$/p\u0026#39; Although forwardslash is not a special character, it is used to separate the pattern and command/script in sed/awk. Thus you need to escape it before use it\nsed -n \u0026#39;/\\//p\u0026#39; Anchor characters include the caret (^) and the dollar sign ($).\n# filter lines begin with the word \u0026#39;hello\u0026#39; sed -n \u0026#39;/^hello/p\u0026#39; # filter lines end with the word \u0026#39;world\u0026#39; sed -n \u0026#39;/world$/p\u0026#39; Note: if the caret is not at the beginning, or the dollar sign is not at the end, they do not act as special characters. which means you do not need to escape them.\nThe dot (.) is used to match any single character except a newline character.\n# filter lines with \u0026#39;.at\u0026#39;, such as \u0026#39;cat\u0026#39;, \u0026#39;hat\u0026#39;, and even \u0026#39; at\u0026#39; sed -n \u0026#39;/.at/p\u0026#39; Square brackets are used to define a class of characters.\n# filter lines with only \u0026#39;cat\u0026#39; or \u0026#39;hat\u0026#39; sed -n \u0026#39;/[ch]at/p\u0026#39; # filter lines with \u0026#39;.at\u0026#39; but except \u0026#39;cat\u0026#39; nor \u0026#39;hat\u0026#39; sed -n \u0026#39;/[^ch]at/p\u0026#39; # filter lines with \u0026#39;hello\u0026#39; non-case-sensitively sed -n \u0026#39;/[Hh][Ee][Ll][Ll][Oo]/p\u0026#39; Use ranges to simplify the character class.\n# filter lines with any digit sed -n \u0026#39;/[0-9]/p\u0026#39; # filter lines with any \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39; or \u0026#39;z\u0026#39; sed -n \u0026#39;/[a-cx-z]/p\u0026#39; There are also some special character classes:\n [[:alpha:]] means [a-zA-Z] [[:alnum:]] means [a-zA-Z0-9] [[:blank:]] means [ \\t] [[:digit:]] means [0-9] [[:lower:]] means [a-z] [[:upper:]] means [A-Z] [[:print:]] means any printable character [[:punct:]] means any punctuation character [[:space:]] means any whitespace character: Space, Tab, NL, FF, VT, CR  Placing an asterisk after a character signifies that the character must appear zero or more times.\n# filter lines with \u0026#39;scho*l\u0026#39;, such as \u0026#39;schl\u0026#39;, \u0026#39;schol\u0026#39; and \u0026#39;school\u0026#39;. sed -n \u0026#39;/scho*l/p\u0026#39; # combined with dot sed -n \u0026#39;/sch.*l/p\u0026#39; # combined with character class sed -n \u0026#39;/sch[oO]*l/p\u0026#39; 3.2 Extended regular expressions Extended regular expressions provide more features. But they are not supported by sed.\nThe question mark is used after a character to signify that the character must appear zero or one time.\n# filter lines with \u0026#39;bt\u0026#39; or \u0026#39;bet\u0026#39; sed -n \u0026#39;/be?t/p\u0026#39; The plus sign is used after a character to signify that the character must appear one or more times.\n# filter lines with \u0026#39;bet\u0026#39;, \u0026#39;beet\u0026#39; or \u0026#39;beeeeet\u0026#39; sed -n \u0026#39;/be+t/p\u0026#39; Curly braces are used to specify a limit on a repeatable pattern.\n# filter lines with \u0026#39;beet\u0026#39; sed -n \u0026#39;/be{2}t/p\u0026#39; # filter lines with \u0026#39;beet\u0026#39; or \u0026#39;beeet\u0026#39; sed -n \u0026#39;/be{2,3}t/p\u0026#39; The pipe symbol (|) is used to combine two or more patterns via logical OR.\n# filter lines with \u0026#39;cat\u0026#39; or \u0026#39;dog\u0026#39; sed -n \u0026#39;/cat|dog/p\u0026#39; Parentheses are used to group a pattern in another pattern.\n# here the pattern \u0026#39;urday\u0026#39; acts as a character sed -n \u0026#39;/Sat(urday)?/p\u0026#39; "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/shell-scripting/",
        "title": "Shell Scripting",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.08.06",
        "body": "1. Basic scripting building 1.1 Display messages Use echo to display messages.\necho \u0026#34;Hello world!\u0026#34; 1.2 Use variables Define and reference a variable.\nval=10 echo ${val} In most cases, the curly brackets can be ignored.\nval=str # ignore curly brackets echo $val # ignoring curly brackets will lead to error echo ${val}ing Define and reference an array.\na[0]=1 echo ${a[0]} # or a = (1 2 3) echo ${a[0]} Note: bash treats all values as string.\n1.3 Exit Use echo $? to check the exit status. Use exit N to return the status N.\n2. Conditional statements 2.1 if-then statements if command; then commands elif command; then commands else commands fi The commands under the then statement will be executed only if the command after if statement is a valid command and the exit status is zero.\n2.2 Testing conditions Besides commands, bash provides a way to test conditions. There are three types of conditions:\n numeric comparisons string comparisons file comparisons  Use double parentheses for numeric comparisons, including most operators in C and ** for exponentiation.\nif (( expression )); then commands fi Use double square brackets for string comparisons, including normal string operators and =~ for regular expression.\nif [[ comparison ]]; then commands fi The file comparisons are the most powerful and most used comparisons in shell scripting.\nif [ condition ]; then commands fi    Comparison Description     -e file Check if file exists   -d file Check if file exists and is a directory   -f file Check if file exists and is a file   -r file Check if file exists and is readable   -w file Check if file exists and is writable   -x file Check if file exists and is executable   -s file Check if file exists and is not empty   -O file Check if file exists and is owned by the current user   -G file Check if file exists and is owned by the current group   file1 -nt file2 Check if file1 is newer than file2   file1 -ot file2 Check if file1 is older than file2    In addition, you can combine conditions using AND (\u0026amp;\u0026amp;) and OR (||).\n2.3 case statements case variable in pattern1) commands ;; pattern2 | pattern3) commands ;; *) commands ;; esac 3. Looping statements 3.1 for statements for var in words; do commands done We can create words by brace expansion, wildcards or command substitution.\n# brace expansion for var in {a..z}; do commands done # wildcards for var in *.txt; do commands done # command substitution for var in $(command); do commands done We can change the value of IFS to change separator temporarily.\nIFS.OLD=$IFS IFS=$\u0026#39;\\n\u0026#39;:;\u0026#34; commands IFS=$IFS.OLD Bash also provides the C-style for statements.\nfor (( expression1; expression2; expression3 )); do commands done 3.2 while and until statements # while while command; do commands done # until until command; do commands done 3.3 Control the loop Two commands are used to control what happens inside of a loop:\n break continue  break n can indicate the level of the loop to break out of. By default n is 1.\n3.4 Process the output of a loop You can redirect or pipe the output of a loop within the script.\n# redirect for var in words; do commands done \u0026gt; output.txt # pipe for var in words; do commands done | grep txt 4. Handle input 4.1 Command line parameters  Use $0 to refer to the script name. Use $1, $2 and so on to refer to the command line parameters. If the number is larger than 9, use curly brackets ${n}. $# contains the number of parameters. Use ${!#} to refer the last parameter.  Both $* and $@ include all the command line parameters. The former takes all the parameters as a single word, while the latter takes all the parameters as separate words.\n4.2 Being shifty shift moves each parameter variable one position to the left by default. For example, after shift command, $3 refers to the fourth parameter, $2 refers to the third parameter, and $1 refers to the second parameter. Note that $0 always refers to the script name.\nYou can use shift to work with options.\nwhile [ -n \u0026#34;$1\u0026#34; ]; do case \u0026#34;$1\u0026#34; in -a) commands ;; *) echo \u0026#34;Error\u0026#34; ;; esac shift done Usually the Linux-style command looks like command options parameter, and some options even requre another parameters, such as\nls -a rm -rf file curl -o outputfile url In such cases, getopts is a better choice rather than shift.\ngetopts optstring opt The optstring lists all valid option characters. A colon after a character means the option requires a value. Each time it is invoked, an option is assigned in opt, and the index of next option is assigned in OPTIND. If the option requres a value, it will be stored in OPTARG. Thus OPTIND should be initialized as 1 at first. Here is an example.\nOPTIND=1 while getopts a:bc opt; do case \u0026#34;$opt\u0026#34; in a) # store value in val val=$OPTARG commands ;; b) commands ;; c) commands *) echo \u0026#34;Error\u0026#34; ;; esac done shift $(($OPTIND-1)) for var in \u0026#34;$@\u0026#34;; do commands done 4.3 Get user input There are two forms of read command:\n# form 1 echo -n question read var # form 2 read -p question var Use -t option to deal with timing out.\necho -n question if read -t seconds var; then commands else echo \u0026#34;Time out!\u0026#34; fi Use -n option to limit the input size.\n# accept only one character read -n1 var Use -s option to prevent the input from displaying on the monitor.\necho -n \u0026#34;Enter your password: \u0026#34; read -s passwd Read from file.\ncat file.txt | while read line; do commands done 5. File descriptors 5.1 Redirect to a file descriptor command \u0026gt;\u0026amp;2 5.2 Redirect a file descriptor to files exec 1\u0026gt;file1 exec 0\u0026lt;file2 5.3 Create your own file descriptors exec 3\u0026gt;file1 exec 4\u0026lt;file2 exec 5\u0026lt;\u0026gt;file3 Save the STDIN/STDOUT file descriptor location to another file descriptor temporarily to read/write a file.\nexec 3\u0026gt;\u0026amp;1 exec 1\u0026gt;file1 echo \u0026#34;hello world\u0026#34; # write to file1 exec 1\u0026gt;\u0026amp;3 echo \u0026#34;hello world\u0026#34; # write to STDOUT exec 3\u0026lt;\u0026amp;0 exec 0\u0026lt;file2 read var # read from file2 exec 0\u0026lt;\u0026amp;3 read var # read from STDIN Close file descriptors.\nexec 3\u0026gt;\u0026amp;- 6. Trap signals To trap signals in a script:\ntrap command signals # the trap can be modified trap command2 signals # also can be removed trap -- signals To trap a script exit\ntrap commands EXIT 7. Create functions 7.1 Basic script functions There are two forms to define a function.\n# form 1 function name { commands } #form 2 name() { commands } 7.2 Return a value The return statement is different from other programming languages. It return the exit status of the function. The exit status must be in the range of 0 to 255.\nfunction func { commands return 0 } func echo \u0026#34;The exit status is $?\u0026#34; To return a value like other programming languages, you can capture the output of the function.\nfunction func { commands echo output } output=$(func) 7.3 Use variables in functions The bash shell treats functions just like scripts. You can pass parameters to a function just like a regular script.\nfunction func { command } func parameters Parameters can also be passed to functions via global variables.\nvar=1 function func { var=2 } func # var=2 echo \u0026#34;var=$var\u0026#34; To avoid modifying the value defined outside functions, you can use local variables.\nvar=1 function func { local var=2 } func # var=1 echo \u0026#34;var=$var\u0026#34; 7.4 Array variables and functions Passing an array to a function is very confusing.\nfunction func { local newarray newarray=(;\u0026#39;echo \u0026#34;$@\u0026#34;\u0026#39;) echo ${newarray[*]} } myarray1=(1 2 3) myarray2=($(func $myarray1)) 7.5 Function recursion function func { commands var=$(func) commands } 7.6 Create a library To use functions defined in other script files:\nsource script_file.sh 7.7 Use functions on the command line Define functions in the .bashrc file, then you can use them in the command line.\n"
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/learning-linux/",
        "title": "Learning Linux",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.06.11",
        "body": "1. Basic commands Navigate the filesystem \u0026amp; manipulate directories and files.\n   name description     cd change directory   ls list   cp copy   mv move   rm remove   ln create links   mkdir create directories    View the contents of files.\n   name description     file determine file type   cat view entire contents of a file   less view entire contents of a file   head view top lines of a file   tail view bottom lines of a file    Monitor system status.\n   name description     ps show processes status   top show processes status dynamically   free show memory usage   df report file system disk space usage   du estimate file space usage    Use commands.\n   name description     man show reference manuals   which show the full path of command   type show description of command type   history show command history   alias define or display aliases    2. Run commands in shell 2.1 IO redirection Redirect output.\n# overwriting the file command \u0026gt; file # appending output to the file command \u0026gt;\u0026gt; file # suppressing output. command \u0026gt; /dev/null Redirect input.\ncommand \u0026lt; inputfile # inline input redirection command \u0026lt;\u0026lt; marker data marker There is no dedicated redirection operator for redirecting errors. We have to refer to its file descriptor. The bash shell reserves the first three file descriptors as STDIN (0), STDOUT (1) and STDERR (2).\ncommand 2\u0026gt; file Redirect both output and errors.\ncommand 1\u0026gt; file1 2\u0026gt; file2 command \u0026amp;\u0026gt; file 2.2 Pipes command1 | command2 Use tee to construct a T pipe.\n# the output of command1 will be saved to file and passed to command2 command1 | tee file | command2 Some commands can be a filter in pipes.\n   name description     sort sort lines   uniq remove duplicates   tr transliterate characters   grep pattern matching by lines   sed stream editor   awk pattern scanning and processing   wc word count    2.3 Expansion Wildcards.\n   Wildcard Meaning     * match any characters   ? match any single character   [characters] match any character in brackets   [!characters] match any character not in brackets   [[:class:]] match any character in class    Class include [[:alnum:]], [[:alpha:]], [[:digit:]], [[:lower:]] and [[:upper:]].\nPathname expansion.\n# list all txt files ls *.txt # tilde for home directory cd ~ Arithmetic expansion. It only supports integer arithmetic.\n$((expression)) # the result is 2 echo $((5/2)) Brace expansion.\n# the result is \u0026#34;file1 file2 file3\u0026#34; echo file{1,2,3} # use range echo file{1..3} # nested brace expansion # the result is \u0026#34;file13 file14 file23 file 24\u0026#34; echo file{1{3,4},2{3,4}} Variable expansion.\n$var Command substitution.\n$(command) `command` Double quoting.\n# all characters are treated as ordinary characters # except dollar sign, backslash and backquote echo \u0026#34;~ will not be expanded as home directory\u0026#34; echo \u0026#34;$varstill show the value of var\u0026#34; echo \u0026#34;backslash is used to escape special characters such as \\$\u0026#34; Single quoting.\n# suppress all expansion echo \u0026#39;$(ls)\u0026#39; 2.4 Jobs Run commands one after one.\ncommand1; command2 Commands are run in foreground mode by default. Run commands in background mode.\n# run in background command \u0026amp; # show jobs launched from current terminal jobs # return the job to foreground fg %n If you exit the terminal session, all jobs, even in background mode, will be interrupted. To avoid this, run scripts without a hang-up.\nnohup command \u0026amp; The nohup command disassociates the process from the terminal, thus it redirects STDOUT and STDERR to nohup.out file. Be careful if you run multiple commands using nohup. All output is appended to nohup.out.\nUse Ctrl+C to interrupt the current-running job. Use Ctrl+Z to stop the current running job. Usually we use Ctrl+Z to move the current-running job to background.\ncommand # stop by Ctrl+Z # show the job number jobs # move to background bg %n # or return to foreground fg %n Use kill and killall to send other signals to processes.\n3. Environment variables Linux environment variables help to store system information, temporary data and configuration information.\nDefine a environment variable.\nvariable_name=variable_value echo $variable_name Define a global environment variable.\nvariable_name=variable_value export variable_name echo $variable_name Add new path.\nPATH=$PATH:/your/new/path 4. File permissions The permission of each file is in form of -rwxrwxrwx. The first character defines the type of the file.\n - for files d for directories l for links c for character devices b for block devices n for network devices  After that define the permissions of the owner, the group owning the file, and everyone else.\n   name description     chmod change file mod bits   chown change file owner and group    5. Filesystem The default filesystem of linux is ext filesystem. The ext filesystem uses an inode system to create a inode table, to store file information, including filename, file size, the owner \u0026amp; group, file permission and pointers to disk block.\nThe ext4 filesystem, the newest ext filesystem, is a journaling filesystem. It write file changes into a temporary file first. After data is successfully written to the storage device and the inode table is updated, the journal file is deleted. Other journaling filesystems include XFS and ReiserFS.\nAn alternative to journaling is copy-on-write. For modifying data, a snapshot is used. Even when data modification is completed, the old data is never overwritten. COW filesystems include ZFS and Btrfs.\n   name description     mount mount storage devices   fdisk manipulate disk partition table   mkfs build a Linux filesystem   fsck check and repair a Linux filesystem    Linux Logical Volume Manager (LVM) is used for managing logical volumes.\n6. Utilities in Linux world 6.1 Package management system Use packege management system to install software.\n   Linux distribution Package management system     Debian dpkg/apt   Redhat rpm/yum   OpenSuse zypper   Archlinux pacman   Gentoo emerge    6.2 Network    name description     ping verify the network connection   wget network download   curl transfer a URL   ssh remote login   scp secure file copy   sftp secure file transfer    6.3 Archive    name description     tar archiving utility   gzip compress files   rsync remote file and directory synchronization    6.4 Find files    name description     touch change file timestamp   find find files   xargs transfer input to args    APPENDIX Common Linux Directory Names\n   directory Usage     / root of the virtual directory   /bin binary directory, where many GNU user-level utilities are stored   /boot boot directory   /dev device directory   /etc system configuration files directory   /home home directory   /lib library directory, where system and application library files are stored   /media media directory, a common place for mount points   /mnt mount directory, another common place for mount points   /opt optional directory, often used to store third-party software packages and data files   /proc process directory, where hardware and process information is stored   /root root home directory   /run run directory, where runtime data is held during system operation   /sbin binary directory, where many GNU admin-level utilities are stored   /srv service directory, where local services store their files   /sys system directory, where system hardware information files are stored   /tmp temporary directory   /usr user binary directory, where the bulk of GNU user-level utilities and data files are stored   /var variable directory, for files that change frequently, such as log files    Linux Process Signals\n   Signal Name Description     1 HUP Hangs up   2 INT Interrupts   3 QUIT Stops running   9 KILL Unconditionally terminates   11 SEGV Produces segment violation   15 TERM Terminates if possible   17 STOP Stops unconditionally, but doesn\u0026rsquo;t terminate   18 TSTP Stops or pauses, but continues to run in background   19 CONT Resumes execution after STOP or TSTP    "
    }
,
    {
        "ref": "https://binzhang-u5f6c.github.io/posts/learning-git/",
        "title": "Learning Git",
        "section": "posts",
        "tags": ["others"],
        "date" : "2020.04.16",
        "body": "1. Git Basics Initializing a repository.\ngit init Clone a repository.\ngit clone \u0026lt;url\u0026gt; \u0026lt;path\u0026gt; Track new files or stage modified file.\ngit add \u0026lt;file\u0026gt; Remove and move files.\ngit rm \u0026lt;file\u0026gt; git mv \u0026lt;file\u0026gt; Commit all staged files.\ngit commit git commit --amend # commit to your last commit Check the status.\ngit status Show commit history.\ngit log git log --patch # show the difference Work with remotes.\ngit remote # show remotes git remote add \u0026lt;remote-name\u0026gt; \u0026lt;url\u0026gt; # add remote git remote rm \u0026lt;remote-name\u0026gt; # remove remote git remote rename \u0026lt;remote-name1\u0026gt; \u0026lt;remote-name2\u0026gt; # rename remote git fetch \u0026lt;remote-name\u0026gt; # fetch the remote git pull \u0026lt;remote-name\u0026gt; \u0026lt;branch\u0026gt; # pull = fetch and merge git push \u0026lt;remote-name\u0026gt; \u0026lt;branch\u0026gt; # push Work with tags.\ngit tag # show tags git tag -a \u0026lt;tag\u0026gt; \u0026lt;commit checksum\u0026gt; # create tag git tag -d \u0026lt;tag\u0026gt; # delete tag git push \u0026lt;remote-name\u0026gt; \u0026lt;tag\u0026gt; # push tag to remote git push \u0026lt;remote-name\u0026gt; --tags # push all tags to remote 2. Branch Git store all data as snapshots. The snapshot is organized in the form of tree structure. Each file is stored as a blob object as the leaf of the snapshot tree. If the file is not modified, git will only store a pointer to its previous blob object.\nWhen making a commit, a commit object is created, including author\u0026rsquo;s name, email, commit message, a pointer to the root node of the snapshot tree, and a pointer to its parent commit.\nBoth tags and branches are pointers to a commit object. Another important pointer is HEAD, which decide what files are shown in the current directory.\nCreate a new branch.\ngit branch \u0026lt;branch\u0026gt; Move the HEAD to point to a branch.\ngit checkout \u0026lt;branch\u0026gt; git checkout -b \u0026lt;branch\u0026gt; # create a branch and switch to it Merge a branch and delete it.\ngit merge \u0026lt;branch\u0026gt; git branch -d \u0026lt;branch\u0026gt; If the merged branch is fast-forward current branch, the command will only move current branch pointer forward. If not, the merging is based on the most recent common ancestor. A new snapshot is created and current branch pointer will be moved to the new snapshot.\nIf a merge conflict occur, git will stop merging and add conflict marker in the files that have conflicts. You have to modify manually and commit to finalize.\ngit commit When you clone a repository from Internet, there are two different pointers for each branch, one normal branch, and one remote-tracking branch. The remote-tracking branch show the branch information of the remote repository. When you commit, only the local branch pointer will move. Fetch will synchronize the remote-tracking branch pointer to the remote repository.\nAfter cloning a repository, git automatically create a local master branch tracking the remote-tracking master branch. If you want to track other branch,\ngit checkout --track \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; # if you want to have a different name git checkout -b \u0026lt;another-name\u0026gt; \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; To set a local branch to a remote-tracking branch,\ngit branch -u \u0026lt;remote-name\u0026gt;/\u0026lt;branch\u0026gt; Delete a remote branch.\ngit push \u0026lt;remote-name\u0026gt; --delete \u0026lt;branch\u0026gt; 3. Rebase Rebase command change the ancestor of a branch. It finds the common ancestor of two branches, gets all changes since the common ancestor, replays the changes to the base branch. The former branch will be deleted.\ngit rebase \u0026lt;base-branch\u0026gt; \u0026lt;topic-branch\u0026gt; Often, rebase is used when you want to contribute a project. Rebase your local branch to origin/master, and submit the pull request. It will be convenient for the maintainer to merge your changes.\nNote:\n Do not rebase commits that exist outside your repository Do not rebase commits that others may have based work on  Compared with merge, rebase will delete some history of your project, but make your project history clear.\n4. Reset and Checkout Git maintains three trees.\n HEAD: last commit snapshot, which the HEAD pointer pointing to Index: files staged and to be commit Working Directory  Reset command do three things:\n move what HEAD points to (stop here if --soft) update the Index with the contents of what HEAD points to (stop here if --mixed or no options) update the Working Directory (stop here if --hard)  Thus git reset HEAD \u0026lt;file\u0026gt; is used to unstage a staged file.\nThe main differences between reset and checkout are:\n Checkout is working-directory safe. Checkout only move the HEAD pointer, while reset move what HEAD points to.  Both reset and checkout can be followed by \u0026lt;paths\u0026gt;. Only the paths, rather than the whole directory, will be act upon.\n5. Debug Find which commit was the first one to introduce a bug or problem.\ngit bisect start git bisect bad git bisect good \u0026lt;good_commit\u0026gt; Annotate the lines with which commit was the last one to introduce a change and who authored that commit.\ngit blame -L \u0026lt;line1\u0026gt;,\u0026lt;line2\u0026gt; \u0026lt;file\u0026gt; Find any string in files, no matter current or older versions.\ngit grep \u0026lt;str\u0026gt; "
    }
]
